module.exports = "# 测试\n\n<p class=\"description\">编写测试能够预防回归问题，并能够带来更好的代码。</p>\n\n本指南使用[来自 Mocha 的全局方法](https://mochajs.org/api/global.html)，而不是使用 [Jest](https://jestjs.io/docs/en/api)。\n\n## 内部\n\nMaterial-UI has **a wide range** of tests so we can iterate with confidence on the components, for instance, the visual regression tests provided by [Argos-CI](https://www.argos-ci.com/Foso/material-ui) have proven to be really helpful. To learn more about the internal tests, you can have a look at the [README](https://github.com/Foso/material-ui/blob/master/test/README.md).\n\n## 用户空间\n\n在用户空间编写测试会如何呢？ Material-UI样式基础架构使用构建在 [enzyme](https://github.com/airbnb/enzyme) 之上的一些辅助函数来使过程更容易，我们正在暴露。 若你愿意，你可以对它们加之利用。 我们几乎只使用完整的 DOM 渲染 API。 尤其若您的组件依赖于自定义主题，我们建议您执行相同的操作。 那些使用浅层渲染 API 的测试会变得更脆弱，因为他们需要一定量的 provider 组件。\n\n### 完整的 DOM 渲染\n\n当你有组件可能会与 DOM API 产生交互，或者当为了完整测试组件而要求完整的生命周期时，用例会更趋向使用完整的 DOM 渲染（例如，`componentDidMount` 等等。）。\n\n为这种情况提供了 `createMount()` 函数。 除了封装 enzyme 的 API，它还提供了一个 `cleanUp` 函数。\n\n### Shallow rendering（浅层渲染）\n\n当把测试的组件当做一个小的单元时，浅层渲染起到了很好的约束作用。 这样也确保了你的测试不会间接地断言子组件的行为。 浅层渲染的目的是单独测试组件。 也就是说子元素的具体实现，如上下文信息，不会被泄漏。\n\n`createShallow()` 函数可用于此情况。 除了包装酶API，它提供 `dive`untilSelector`直到选择` 选项。\n\n### 渲染为字符串\n\n当在测试服务器组件行为时，渲染为字符串会有帮助。 你可以依此来断言所生成的 HTML 字符串。\n\n`createRender()` 函数非常适合这种情况。 这只是enzyme API的别名，只是为了保持一致性而暴露。\n\n## API\n\n### `createMount([options]) => mount`\n\n在特定的情况下，您能够生成一个加强版的 mount 函数。 有关 `mount` 功能的更多详细信息，请参阅 [enzyme API文档](https://airbnb.io/enzyme/docs/api/mount.html)。\n\n#### 参数\n\n1. `options` (*Object* [optional]) \n  - `options.mount` (*Function* [optional])：用 mount 函数来增强，它**默认使用 enzyme **。\n  - 其他的键则被转发到 `enzyme.mount()` 的 options 参数当中。\n\n#### 返回结果\n\n`mount` (*mount*)：安装功能。\n\n#### 示例\n\n```jsx\nimport { createMount } from '@material-ui/core/test-utils';\nimport { ThemeProvider } from '@material-ui/core/styles';\n\ndescribe('<MyComponent />', () => {\n  let mount;\n\n  function MySuccessButton({ children }) {\n    return (\n      <ThemeProvider theme={{ success: { main: '#fff' } }}>\n        {children}\n      </ThemeProvider>\n    );\n  }\n\n  before(() => {\n    mount = createMount();\n  });\n\n  after(() => {\n    mount.cleanUp();\n  });\n\n  it('should work', () => {\n    const wrapper = mount(<MockedTheme><MySuccessButton /></MockedTheme>);\n  });\n});\n```\n\n### `createShallow([options]) => shallow`\n\n在特定的情况下，您能够生成一个加强版的浅层函数。 有关 `shallow`函数的更多详细信息, 请参考[enzyme API 文档 ](https://airbnb.io/enzyme/docs/api/shallow.html),\n\n#### 参数\n\n1. `options` (*Object* [optional]) \n  - `options.shallow`(*Function* [optional])：用浅层函数来增强，它**默认使用 enzyme **。\n  - `options.untilSelector`(*String* [optional])：递归地浅层渲染子项，直到找到提供的选择器。 进一步探索 higher-order components（高阶组件）是很有帮助的。\n  - `options.dive` (*Boolean* [optional])：浅层函数能够渲染当前包装器的一个非 DOM 的子节点，并返回一个含有结果的包装器。\n  - 其他的键则被转发到 `enzyme.shallow()` 的 options 参数当中。\n\n#### 返回结果\n\n`shallow` （*shallow*）：浅函数。\n\n#### 示例\n\n```jsx\nmport { createShallow } from '@material-ui/core/test-utils';\n\ndescribe('<MyComponent />', () => {\n  let shallow;\n\n  before(() => {  // 这个是 Mocha；而在 Jest 中, 请使用 beforeAll\n    shallow = createShallow();\n  });\n\n  it('should work', () => {\n    const wrapper = shallow(<MyComponent />);\n  });\n});\n```\n\n### `createRender([options]) => render`\n\n在特定的情况下，您能够生成一个加强版的字符串函数。 有关 `render` 功能的更多详细信息，请参阅 [enzyme API文档](https://airbnb.io/enzyme/docs/api/render.html)。\n\n#### 参数\n\n1. `options` (*Object* [optional]) \n  - `options.render` (*Function* [optional])：用渲染函数来增强，它**默认使用 enzyme **。\n  - 其他的键则被转发到 `enzyme.render()` 的 options 参数当中。\n\n#### 返回结果\n\n`render` (*Function*)：渲染到字符串函数。\n\n#### 示例\n\n```jsx\nimport { createRender } from '@material-ui/core/test-utils';\n\ndescribe('<MyComponent />', () => {\n  let render;\n\n  before(() => {\n    render = createRender();\n  });\n\n  it('should work', () => {\n    const wrapper = render(<MyComponent />);\n  });\n});\n```\n"