module.exports = "# Composition（组合）\n\n<p class=\"description\">Material-UI 试着让组合尽可能的简单。</p>\n\n## 封装组件\n\n我们需要一种了解组件接收的子元素的本质的方式，这样可以尽可能提供最大的灵活性和最好的性能。 To solve this problem we tag some of the components with a `muiName` static property when needed.\n\n但是，您仍可能需要封装一个组件以增强它的功能，而这可能与 `muiName` 的解决方案相冲突。 If you wrap a component, verify if that component has this static property set.\n\n如果您遇到此问题，那么请为封装组件附加上与被封装组件一样的标记。 另外，鉴于父组件可能需要对被封装的组件属性加以控制，您应该向父组件传递这些属性。\n\n让我们来看一个例子：\n\n```jsx\nconst WrappedIcon = props => <Icon {...props} />;\nWrappedIcon.muiName = Icon.muiName;\n```\n\n{{\"demo\": \"pages/guides/composition/Composition.js\"}}\n\n## Component prop\n\nMaterial-UI allows you to change the root element that will be rendered via a prop called `component`.\n\n### 它是如何工作的呢？\n\n该组件将这样渲染：\n\n```js\nreturn React.createElement(props.component, props)\n```\n\n例如，在默认情况下，`List` 组件会渲染 `<ul>` 元素。 This can be changed by passing a [React component](https://reactjs.org/docs/components-and-props.html#function-and-class-components) to the `component` prop. The following example will render the `List` component with a `<nav>` element as root element instead:\n\n```jsx\n<List component=\"nav\">\n  <ListItem button>\n    <ListItemText primary=\"Trash\" />\n  </ListItem>\n  <ListItem button>\n    <ListItemText primary=\"Spam\" />\n  </ListItem>\n</List>\n```\n\nThis pattern is very powerful and allows for great flexibility, as well as a way to interoperate with other libraries, such as your favorite routing or forms library. 但它也**带有一个小小的警告!**\n\n### 当与内联函数一起使用时要注意\n\nUsing an inline function as an argument for the `component` prop may result in **unexpected unmounting**, since a new component is passed every time React renders. 例如，如果要创建自定义` ListItem `作为链接，您可以执行以下操作：\n\n```jsx\nimport { Link } from 'react-router-dom';\n\nfunction ListItemLink(props) {\n  const { icon, primary, to } = props;\n\n  return (\n    <li>\n      <ListItem button component={props => <Link to={to} {...props} />}>\n        <ListItemIcon>{icon}</ListItemIcon>\n        <ListItemText primary={primary} />\n      </ListItem>\n    </li>\n  );\n}\n```\n\n⚠️然而，由于我们使用内联函数来更改呈现的组件，因此，在每一次` ListItemLink `被渲染时，React都会先将它卸载。 不只是React会更新那些不必要的DOM，`ListItem` 的涟漪效应也将无法正常工作。\n\nThe solution is simple: **avoid inline functions and pass a static component to the `component` prop** instead. Let's change the `ListItemLink` to the following:\n\n```jsx\nimport { Link } from 'react-router-dom';\n\nfunction ListItemLink(props) {\n  const { icon, primary, to } = props;\n\n  const renderLink = React.useMemo(\n    () =>\n      React.forwardRef((linkProps, ref) => (\n        <Link ref={ref} to={to} {...linkProps} />\n      )),\n    [to],\n  );\n\n  return (\n    <li>\n      <ListItem button component={renderLink}>\n        <ListItemIcon>{icon}</ListItemIcon>\n        <ListItemText primary={primary} />\n      </ListItem>\n    </li>\n  );\n}\n```\n\n` renderLink `现在将始终引用相同的组件。\n\n### Caveat with prop forwarding\n\nYou can take advantage of the prop forwarding to simplify the code. 在此示例中，我们不创建任何中间组件：\n\n```jsx\nimport { Link } from 'react-router-dom';\n\n<ListItem button component={Link} to=\"/\">\n```\n\n⚠️ However, this strategy suffers from a limitation: prop collisions. The component providing the `component` prop (e.g. ListItem) might not forward all the props (for example dense) to the root element.\n\n### 使用 TypeScript\n\n您可以在[ TypeScript指南中找到详细信息](/guides/typescript/#usage-of-component-prop) 。\n\n## Routing libraries\n\nThe integration with third-party routing libraries is achieved with the `component` prop. The behavior is identical to the description of the prop above. Here are a few demos with [react-router-dom](https://github.com/ReactTraining/react-router). It covers the Button, Link, and List components, you should be able to apply the same strategy with all the components.\n\n### Buttons（按钮）\n\n{{\"demo\": \"pages/guides/composition/ButtonRouter.js\"}}\n\n### Link\n\n{{\"demo\": \"pages/guides/composition/LinkRouter.js\"}}\n\n### Lists（列表）\n\n{{\"demo\": \"pages/guides/composition/ListRouter.js\"}}\n\n## 使用refs时要注意\n\n本节介绍将自定义组件用作`子组件`或`component`属性的值时的注意事项。\n\n某些组件需要访问DOM节点。 之前提到，通过使用` ReactDOM.findDOMNode ` 就能实现。 该方法已被废弃，代替的是使用` ref `和 ref 转递。 然而，只有下列组件类型才可获得 `ref`：\n\n- 任何Material-UI组件\n- 类组件，如 `React.Component` 或 `React.PureComponent` 等\n- DOM (或 host) 组件，例如 `div` 或 `button`等\n- [React.forwardRef组件](https://reactjs.org/docs/react-api.html#reactforwardref)\n- [React.lazy组件](https://reactjs.org/docs/react-api.html#reactlazy)\n- [React.memo组件](https://reactjs.org/docs/react-api.html#reactmemo)\n\n如果在将组件与Material-UI结合使用时未使用上述类型之一，则可能会在控制台中看到来自React的警告，类似于：\n\n> Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?\n\n请注意，在使用 `lazy` 和 `memo` 组件时，如果被封装的组件无法持有 ref，您仍然有可能收到这个警告。\n\nIn some instances an additional warning is issued to help with debugging, similar to:\n\n> Invalid prop `component` supplied to `ComponentName`. Expected an element type that can hold a ref.\n\nOnly the two most common use cases are covered. 更多信息见[React官方文档中的本章节](https://reactjs.org/docs/forwarding-refs.html)。\n\n```diff\n- const MyButton = props => <div role=\"button\" {...props} />;\n+ const MyButton = React.forwardRef((props, ref) => <div role=\"button\" {...props} ref={ref} />);\n<Button component={MyButton} />;\n```\n\n```diff\n- const SomeContent = props => <div {...props}>Hello, World!</div>;\n+ const SomeContent = React.forwardRef((props, ref) => <div {...props} ref={ref}>Hello, World!</div>);\n<Tooltip title=\"Hello, again.\"><SomeContent /></Tooltip>;\n```\n\n要确定您使用的Material-UI组件是否具有此需求，请查阅该组件的props API文档。 如果您需要转递 refs，描述将链接到此部分。\n\n### Caveat with StrictMode\n\nIf you use class components for the cases described above you will still see warnings in `React.StrictMode`. `ReactDOM.findDOMNode` is used internally for backwards compatibility. You can use `React.forwardRef` and a designated prop in your class component to forward the `ref` to a DOM component. Doing so should not trigger any more warnings related to the deprecation of `ReactDOM.findDOMNode`.\n\n```diff\nclass Component extends React.Component {\n  render() {\n-   const { props } = this;\n+   const { forwardedRef, ...props } = this.props;\n    return <div {...props} ref={forwardedRef} />;\n  }\n}\n\n-export default Component;\n+export default React.forwardRef((props, ref) => <Component {...props} forwardedRef={ref} />);\n```"