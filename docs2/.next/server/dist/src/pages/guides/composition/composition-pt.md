module.exports = "# Composição\n\n<p class=\"description\">Material-UI tenta tornar a composição o mais fácil possível.</p>\n\n## Encapsulando componentes\n\nPara fornecer o máximo de flexibilidade e desempenho, precisamos de uma maneira de conhecer a natureza dos elementos filhos que um componente recebe. Para resolver esse problema, identificamos alguns dos componentes com uma propriedade estática `muiName` quando necessário.\n\nVocê pode, no entanto, precisar encapsular um componente para melhorá-lo, que pode entrar em conflito com a solução `muiName`. Se você encapsular um componente, verifique se este tem um conjunto de propriedades estáticas.\n\nSe você encontrar esse problema, precisará usar a mesma propriedade `muiName` do componente que será encapsulado no seu componente encapsulado. Além disso, você deve encaminhar as propriedades, já que o componente pai pode precisar controlar as propriedades do componente encapsulado.\n\nVamos ver um exemplo:\n\n```jsx\nconst WrappedIcon = props => <Icon {...props} />;\nWrappedIcon.muiName = Icon.muiName;\n```\n\n{{\"demo\": \"pages/guides/composition/Composition.js\"}}\n\n## Propriedade Componente\n\nMaterial-UI permite que você altere o elemento raiz que será renderizado por meio de uma propriedade chamada `component`.\n\n### Como é que funciona?\n\nO componente será renderizado assim:\n\n```js\nreturn React.createElement(props.component, props)\n```\n\nPor exemplo, por padrão um componente `List` irá renderizar um elemento `<ul>`. Isso pode ser alterado passando um [componente React](https://reactjs.org/docs/components-and-props.html#function-and-class-components) para a propriedade `component`. O exemplo a seguir irá renderizar o componente `List` como um elemento `<nav>` como raiz:\n\n```jsx\n<List component=\"nav\">\n  <ListItem button>\n    <ListItemText primary=\"Trash\" />\n  </ListItem>\n  <ListItem button>\n    <ListItemText primary=\"Spam\" />\n  </ListItem>\n</List>\n```\n\nEsse padrão é muito poderoso e permite uma grande flexibilidade, além de uma maneira de interoperar com outras bibliotecas, como a sua biblioteca de formulários ou roteamento favorita. Mas também **vem com uma pequena advertência!**\n\n### Advertência com o uso de funções em linha\n\nUsing an inline function as an argument for the `component` prop may result in **unexpected unmounting**, since a new component is passed every time React renders. Por exemplo, se você quiser cria um `ListItem` customizado que atua como link, você poderia fazer o seguinte:\n\n```jsx\nimport { Link } from 'react-router-dom';\n\nfunction ListItemLink(props) {\n  const { icon, primary, to } = props;\n\n  return (\n    <li>\n      <ListItem button component={props => <Link to={to} {...props} />}>\n        <ListItemIcon>{icon}</ListItemIcon>\n        <ListItemText primary={primary} />\n      </ListItem>\n    </li>\n  );\n}\n```\n\n⚠️ No entanto, como estamos usando uma função em linha para alterar o componente renderizado, o React desmontará o link toda vez que o `ListItemLink` é renderizado. Não só irá o React atualizar o DOM desnecessariamente, como o efeito cascata do `ListItem` também não funcionará corretamente.\n\nThe solution is simple: **avoid inline functions and pass a static component to the `component` prop** instead. Let's change the `ListItemLink` to the following:\n\n```jsx\nimport { Link } from 'react-router-dom';\n\nfunction ListItemLink(props) {\n  const { icon, primary, to } = props;\n\n  const renderLink = React.useMemo(\n    () =>\n      React.forwardRef((linkProps, ref) => (\n        <Link ref={ref} to={to} {...linkProps} />\n      )),\n    [to],\n  );\n\n  return (\n    <li>\n      <ListItem button component={renderLink}>\n        <ListItemIcon>{icon}</ListItemIcon>\n        <ListItemText primary={primary} />\n      </ListItem>\n    </li>\n  );\n}\n```\n\n`renderLink` agora sempre referenciará o mesmo componente.\n\n### Caveat with prop forwarding\n\nYou can take advantage of the prop forwarding to simplify the code. Neste exemplo, não criamos nenhum componente intermediário:\n\n```jsx\nimport { Link } from 'react-router-dom';\n\n<ListItem button component={Link} to=\"/\">\n```\n\n⚠️ However, this strategy suffers from a limitation: prop collisions. The component providing the `component` prop (e.g. ListItem) might not forward all the props (for example dense) to the root element.\n\n### Usando TypeScript\n\nVocê pode encontrar os detalhes no [guia TypeScript](/guides/typescript/#usage-of-component-prop).\n\n## Bibliotecas de roteamento\n\nThe integration with third-party routing libraries is achieved with the `component` prop. The behavior is identical to the description of the prop above. Here are a few demos with [react-router-dom](https://github.com/ReactTraining/react-router). It covers the Button, Link, and List components, you should be able to apply the same strategy with all the components.\n\n### Button\n\n{{\"demo\": \"pages/guides/composition/ButtonRouter.js\"}}\n\n### Link\n\n{{\"demo\": \"pages/guides/composition/LinkRouter.js\"}}\n\n### Lista\n\n{{\"demo\": \"pages/guides/composition/ListRouter.js\"}}\n\n## Advertência com refs\n\nEsta seção aborda advertências ao usar um componente customizado como `children` ou para a propriedade `component`.\n\nAlguns dos componentes precisam acessar o nó DOM. Anteriormente, isso era possível usando `ReactDOM.findDOMNode`. Esta função está obsoleta em favor da utilização de `ref` e encaminhamento de ref. No entanto, apenas os seguintes tipos de componentes podem receber um `ref`:\n\n- Qualquer componente do Material-UI\n- componentes de classe, ou seja, `React.Component` ou `React.PureComponent`\n- Componentes DOM (ou hospedeiro), por exemplo, `div` ou `button`\n- [Componentes React.forwardRef](https://reactjs.org/docs/react-api.html#reactforwardref)\n- [Componentes React.lazy](https://reactjs.org/docs/react-api.html#reactlazy)\n- [Componentes React.memo](https://reactjs.org/docs/react-api.html#reactmemo)\n\nSe você não usar um dos tipos acima ao usar seus componentes em conjunto com o Material-UI, poderá ver um aviso do React no seu console semelhante a:\n\n> Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?\n\nEsteja ciente que você ainda receberá este aviso para componentes `lazy` ou `memo` se eles forem encapsulados por um componente que não contém ref.\n\nIn some instances an additional warning is issued to help with debugging, similar to:\n\n> Invalid prop `component` supplied to `ComponentName`. Expected an element type that can hold a ref.\n\nOnly the two most common use cases are covered. Para mais informações, consulte [esta seção na documentação oficial do React](https://reactjs.org/docs/forwarding-refs.html).\n\n```diff\n- const MyButton = props => <div role=\"button\" {...props} />;\n+ const MyButton = React.forwardRef((props, ref) => <div role=\"button\" {...props} ref={ref} />);\n<Button component={MyButton} />;\n```\n\n```diff\n- const SomeContent = props => <div {...props}>Olá mundo!</div>;\n+ const SomeContent = React.forwardRef((props, ref) => <div {...props} ref={ref}>Olá mundo!</div>);\n<Tooltip title=\"Hello, again.\"><SomeContent /></Tooltip>;\n```\n\nPara descobrir se o componente de Material-UI que você está usando tem esse requisito, verifique na documentação de propriedades da API do componente. Se você precisar encaminhar refs, a descrição será vinculada a esta seção.\n\n### Caveat with StrictMode\n\nIf you use class components for the cases described above you will still see warnings in `React.StrictMode`. `ReactDOM.findDOMNode` is used internally for backwards compatibility. You can use `React.forwardRef` and a designated prop in your class component to forward the `ref` to a DOM component. Doing so should not trigger any more warnings related to the deprecation of `ReactDOM.findDOMNode`.\n\n```diff\nclass Component extends React.Component {\n  render() {\n-   const { props } = this;\n+   const { forwardedRef, ...props } = this.props;\n    return <div {...props} ref={forwardedRef} />;\n  }\n}\n\n-export default Component;\n+export default React.forwardRef((props, ref) => <Component {...props} forwardedRef={ref} />);\n```"