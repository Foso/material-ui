module.exports = "# Komposition\n\n<p class=\"description\">Die Material-UI versucht die Komposition so einfach wie möglich zu gestalten.</p>\n\n## Komponenten verpacken\n\nUm maximale Flexibilität und Leistung zu gewährleisten, benötigen wir einen Weg, um die Art der untergeordneten Elemente einer Komponente zu kennen. To solve this problem we tag some of the components with a `muiName` static property when needed.\n\nYou may, however, need to wrap a component in order to enhance it, which can conflict with the `muiName` solution. If you wrap a component, verify if that component has this static property set.\n\nIf you encounter this issue, you need to use the same tag for your wrapping component that is used with the wrapped component. In addition, you should forward the properties, as the parent component may need to control the wrapped components props.\n\nSehen wir uns ein Beispiel an:\n\n```jsx\nconst WrappedIcon = props => <Icon {...props} />;\nWrappedIcon.muiName = Icon.muiName;\n```\n\n{{\"demo\": \"pages/guides/composition/Composition.js\"}}\n\n## Component prop\n\nMaterial-UI allows you to change the root element that will be rendered via a prop called `component`.\n\n### Wie funktioniert das?\n\nDie Komponente wird wie folgt gerendert:\n\n```js\nreturn React.createElement(props.component, props)\n```\n\nBeispielsweise wird die `List` Komponente mit einem `<ul>`-Element gerendert. This can be changed by passing a [React component](https://reactjs.org/docs/components-and-props.html#function-and-class-components) to the `component` prop. The following example will render the `List` component with a `<nav>` element as root element instead:\n\n```jsx\n<List component=\"nav\">\n  <ListItem button>\n    <ListItemText primary=\"Trash\" />\n  </ListItem>\n  <ListItem button>\n    <ListItemText primary=\"Spam\" />\n  </ListItem>\n</List>\n```\n\nThis pattern is very powerful and allows for great flexibility, as well as a way to interoperate with other libraries, such as your favorite routing or forms library. Aber es gibt auch eine **kleine Einschränkung!**\n\n### Vorbehalt beim Inlining\n\nUsing an inline function as an argument for the `component` prop may result in **unexpected unmounting**, since a new component is passed every time React renders. Zum Beispiel, wenn Sie ein benutzerdefiniertes `ListItem` erstellen möchten, das als Link fungiert, können Sie Folgendes tun:\n\n```jsx\nimport { Link } from 'react-router-dom';\n\nfunction ListItemLink(props) {\n  const { icon, primary, to } = props;\n\n  return (\n    <li>\n      <ListItem button component={props => <Link to={to} {...props} />}>\n        <ListItemIcon>{icon}</ListItemIcon>\n        <ListItemText primary={primary} />\n      </ListItem>\n    </li>\n  );\n}\n```\n\n⚠️ Da wir jedoch eine Inline-Funktion verwenden, um die gerenderte Komponente zu ändern, wird die Verknüpfung von React bei jedem Rendern des `ListItemLink ` aufgehoben. React aktualisiert nicht nur das DOM unnötig, sondern die Wellenvisualisierung des `ListItem` funktioniert auch nicht richtig.\n\nThe solution is simple: **avoid inline functions and pass a static component to the `component` prop** instead. Let's change the `ListItemLink` to the following:\n\n```jsx\nimport { Link } from 'react-router-dom';\n\nfunction ListItemLink(props) {\n  const { icon, primary, to } = props;\n\n  const renderLink = React.useMemo(\n    () =>\n      React.forwardRef((linkProps, ref) => (\n        <Link ref={ref} to={to} {...linkProps} />\n      )),\n    [to],\n  );\n\n  return (\n    <li>\n      <ListItem button component={renderLink}>\n        <ListItemIcon>{icon}</ListItemIcon>\n        <ListItemText primary={primary} />\n      </ListItem>\n    </li>\n  );\n}\n```\n\n`renderLink` wird jetzt immer auf dieselbe Komponente verweisen.\n\n### Caveat with prop forwarding\n\nYou can take advantage of the prop forwarding to simplify the code. In diesem Beispiel erstellen wir keine Zwischenkomponente:\n\n```jsx\nimport { Link } from 'react-router-dom';\n\n<ListItem button component={Link} to=\"/\">\n```\n\n⚠️ However, this strategy suffers from a limitation: prop collisions. The component providing the `component` prop (e.g. ListItem) might not forward all the props (for example dense) to the root element.\n\n### Mit TypeScript\n\nDie Details finden Sie im [TypeScript-Handbuch](/guides/typescript/#usage-of-component-prop).\n\n## Routing libraries\n\nThe integration with third-party routing libraries is achieved with the `component` prop. The behavior is identical to the description of the prop above. Here are a few demos with [react-router-dom](https://github.com/ReactTraining/react-router). It covers the Button, Link, and List components, you should be able to apply the same strategy with all the components.\n\n### Button\n\n{{\"demo\": \"pages/guides/composition/ButtonRouter.js\"}}\n\n### Link\n\n{{\"demo\": \"pages/guides/composition/LinkRouter.js\"}}\n\n### List (liste)\n\n{{\"demo\": \"pages/guides/composition/ListRouter.js\"}}\n\n## Vorbehalt bei Refs\n\nThis section covers caveats when using a custom component as `children` or for the `component` prop.\n\nSome of the components need access to the DOM node. This was previously possible by using `ReactDOM.findDOMNode`. This function is deprecated in favor of `ref` and ref forwarding. However, only the following component types can be given a `ref`:\n\n- Any Material-UI component\n- class components i.e. `React.Component` or `React.PureComponent`\n- DOM (or host) components e.g. `div` or `button`\n- [React.forwardRef components](https://reactjs.org/docs/react-api.html#reactforwardref)\n- [React.lazy components](https://reactjs.org/docs/react-api.html#reactlazy)\n- [React.memo components](https://reactjs.org/docs/react-api.html#reactmemo)\n\nIf you don't use one of the above types when using your components in conjunction with Material-UI, you might see a warning from React in your console similar to:\n\n> Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?\n\nBe aware that you will still get this warning for `lazy` and `memo` components if their wrapped component can't hold a ref.\n\nIn some instances an additional warning is issued to help with debugging, similar to:\n\n> Ungültige `component` Eigenschaft an `ComponentName` übergeben. Es wurde ein Elementtyp erwartet, der eine Referenz enthalten kann.\n\nOnly the two most common use cases are covered. For more information see [this section in the official React docs](https://reactjs.org/docs/forwarding-refs.html).\n\n```diff\n- const MyButton = props => <div role=\"button\" {...props} />;\n+ const MyButton = React.forwardRef((props, ref) => <div role=\"button\" {...props} ref={ref} />);\n<Button component={MyButton} />;\n```\n\n```diff\n- const SomeContent = props => <div {...props}>Hello, World!</div>;\n+ const SomeContent = React.forwardRef((props, ref) => <div {...props} ref={ref}>Hello, World!</div>);\n<Tooltip title=\"Hello, again.\"><SomeContent /></Tooltip>;\n```\n\nUm herauszufinden, ob die Material-UI - Komponente, die Sie verwenden, diese Anforderung hat, überprüfen Sie API - Dokumentation für diese Komponente. Wenn Sie Refs weiterleiten müssen, wird die Beschreibung mit diesem Abschnitt verknüpft.\n\n### Caveat with StrictMode\n\nIf you use class components for the cases described above you will still see warnings in `React.StrictMode`. `ReactDOM.findDOMNode` is used internally for backwards compatibility. You can use `React.forwardRef` and a designated prop in your class component to forward the `ref` to a DOM component. Doing so should not trigger any more warnings related to the deprecation of `ReactDOM.findDOMNode`.\n\n```diff\nclass Component extends React.Component {\n  render() {\n-   const { props } = this;\n+   const { forwardedRef, ...props } = this.props;\n    return <div {...props} ref={forwardedRef} />;\n  }\n}\n\n-export default Component;\n+export default React.forwardRef((props, ref) => <Component {...props} forwardedRef={ref} />);\n```"