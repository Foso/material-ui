module.exports = "# API Design Approach\n\n<p class=\"description\">We have learned a great deal regarding how Material-UI is used, and the v1 rewrite allowed us to completely rethink the component API.</p>\n\n> API design is hard because you can make it seem simple but it's actually deceptively complex, or make it actually simple but seem complex.\n\n[@sebmarkbage](https://twitter.com/sebmarkbage/status/728433349337841665)\n\nAs Sebastian Markbage [pointed out](https://2014.jsconf.eu/speakers/sebastian-markbage-minimal-api-surface-area-learning-patterns-instead-of-frameworks.html), no abstraction is superior to wrong abstractions.\nWe are providing low-level components to maximize composition capabilities.\n\n## Composition\n\nYou may have noticed some inconsistency in the API regarding composing components.\nTo provide some transparency, we have been using the following rules when designing the API:\n\n1. Using the `children` property is the idiomatic way to do composition with React.\n2. Sometimes we only need limited child composition, for instance when we don't need to allow child order permutations.\nIn this case, providing explicit properties makes the implementation simpler and more performant; for example, the `Tab` takes an `icon` and a `label` property.\n3. API consistency matters.\n\n## Rules\n\nAside from the above composition trade-off, we enforce the following rules:\n\n### Spread\n\nUndocumented properties supplied are spread to the root element;\nfor instance, the `className` property is applied to the root.\n\nNow, let's say you want to disable the ripples on the `MenuItem`.\nYou can take advantage of the spread behavior:\n```jsx\n<MenuItem disableRipple />\n```\nThe `disableRipple` property will flow this way: [`MenuItem`](/api/menu-item/) > [`ListItem`](/api/list-item/) > [`ButtonBase`](/api/button-base/).\n\n### Native properties\n\nWe avoid documenting native properties supported by the DOM like [`className`](/customization/components/#overriding-styles-with-class-names).\n\n### CSS Classes\n\nAll the components accept a [`classes`](/customization/components/#overriding-styles-with-classes) property to customize the styles.\nThe classes design answers two constraints:\nto make the classes structure as simple as possible, while sufficient to implement the Material Design specification.\n- The class applied to the root element is always called `root`.\n- All the default styles are grouped in a single class.\n- The classes applied to non-root elements are prefixed with the name of the element, e.g. `paperWidthXs` in the Dialog component.\n- The variants applied by a boolean property **aren't** prefixed, e.g. the `rounded` class\napplied by the `rounded` property.\n- The variants applied by an enum property **are** prefixed, e.g. the `colorPrimary` class\napplied by the `color=\"primary\"` property.\n- A variant has **one level of specificity**.\nThe `color` and `variant` properties are considered a variant.\nThe lower the style specificity is, the simpler it is to override.\n- We increase the specificity for a variant modifier.\nWe already **have to do it** for the pseudo-classes (`:hover`, `:focus`, etc.).\nIt allows much more control at the cost of more boilerplate.\nHopefully, it's also more intuitive.\n\n```js\nconst styles = {\n  root: {\n    color: green[600],\n    '&$checked': {\n      color: green[500],\n    },\n  },\n  checked: {},\n};\n```\n\n### Nested components\n\nNested components inside a component have:\n- their own flattened properties when these are key to the top level component abstraction,\n  for instance and `id` property for the `Input` component.\n- their own `xxxProps` property when users might need to tweak the internal render method's sub-components,\n  for instance, exposing the `inputProps` and `InputProps` properties on components that use `Input` internally.\n- their own `xxxComponent` property for performing component injection.\n- their own `xxxRef` property when user might need to perform imperative actions,\n  for instance, exposing a `inputRef` property to access the native `input` on the `Input` component.\n  This helps answer the  question [\"How can I access the DOM element?\"](/getting-started/faq/#how-can-i-access-the-dom-element)\n\n### Property naming\n\nThe name of a boolean property should be chosen based on the **default value**.\nFor example, the `disabled` attribute on an input element, if supplied, defaults to `true`.\nThis choice allows the shorthand notation:\n\n```diff\n-<Input enabled={false} />\n+<Input disabled />\n```\n\n### Controlled components\n\nMost of the controlled component are controlled via the `value` and the `onChange` properties,\nhowever, the `open` / `onClose` / `onOpen` combination is used for display related state.\n\n### boolean vs enum\n\nThere are two options to design the API for the variations of a component: with a *boolean*; or with an *enum*.\nFor example, let's take a button that has different types. Each option has its pros and cons:\n\n- Option 1 *boolean*:\n\n  ```tsx\n  type Props = {\n    contained: boolean;\n    fab: boolean;\n  };\n  ```\n\n   This API enabled the shorthand notation:\n   `<Button>`, `<Button contained />`, `<Button fab />`.\n\n- Option 2 *enum*:\n\n  ```tsx\n  type Props = {\n    variant: 'text' | 'contained' | 'fab';\n  }\n  ```\n\n  This API is more verbose:\n  `<Button>`, `<Button variant=\"contained\">`, `<Button variant=\"fab\">`.\n\n   However it prevents an invalid combination from being used,\n   bounds the number of properties exposed,\n   and can easily support new values in the future.\n\nThe Material-UI components use a combination of the two approaches according to the following rules:\n- A *boolean* is used when **2** degrees of freedom are required.\n- An *enum* is used when **> 2** degrees of freedom are required, or if there is the possibility that additional degrees of freedom may be required in the future.\n\nGoing back to the previous button example; since it requires 3 degrees of freedom, we use an *enum*.\n\n### Ref\n\nThe `ref` is forwarded to the root element. This means that, without changing the rendered root element\nvia the `component` prop, it is forwarded to the outermost DOM element that which component\nrenders. If you pass a different component via the `component` prop the ref will be attached\nto that component instead.\n\n## Glossary\n\n- **host component**: a DOM node type in the context of `react-dom`, e.g. a `'div'`. See also [React Implementation Notes](https://reactjs.org/docs/implementation-notes.html#mounting-host-elements).\n- **host element**: a DOM node in the context of `react-dom`, e.g. an instance of `window.HTMLDivElement`.\n- **outermost**: The first component when reading the component tree from top to bottom i.e. breadth-first search.\n- **root component**: the outermost component that renders a host component.\n- **root element**: the outermost element that renders a host component.\n"