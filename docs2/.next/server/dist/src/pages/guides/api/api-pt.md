module.exports = "# Abordagem de Design da API\n\n<p class=\"description\">Nós aprendemos bastante como o Material-UI é usado e o refatoramento da v1 permitiu-nos repensar completamente o componente de API.</p>\n\n> O design da API é difícil porque você pode fazer com que pareça simples, mas na verdade é extremamente complexo ou simples, mas parece complexo.\n\n[@sebmarkbage](https://twitter.com/sebmarkbage/status/728433349337841665)\n\nComo Sebastian Markbage [apontou](https://2014.jsconf.eu/speakers/sebastian-markbage-minimal-api-surface-area-learning-patterns-instead-of-frameworks.html), nenhuma abstração é superior a abstrações erradas. Estamos fornecendo componentes de baixo nível para maximizar os recursos de composição.\n\n## Composição\n\nVocê deve ter notado alguma inconsistência na API em relação à composição de componentes. Para fornecer alguma transparência, usamos as seguintes regras ao projetar a API:\n\n1. Usando a propriedade `children` é a maneira idiomática de fazer composição com React.\n2. Às vezes, precisamos apenas de uma composição limitada com child, por exemplo, quando não precisamos permitir permutações de ordem com child. Nesse caso, fornecer propriedades explícitas torna a implementação mais simples e com maior desempenho; por exemplo, o componente `Tab` recebe uma propriedade `icon` e `label`.\n3. A consistência da API é importante.\n\n## Regras\n\nAlém do trade-off da composição acima, aplicamos as seguintes regras:\n\n### Propagar\n\nPropriedades não documentadas fornecidas são propagadas no elemento raiz; por exemplo, a propriedade `className` é aplicada à raiz.\n\nAgora, digamos que você queira desabilitar o efeito cascata do `MenuItem`. Você pode aproveitar o comportamento de propagação:\n\n```jsx\n<MenuItem disableRipple />\n```\n\nA propriedade `disableRipple` fluirá desta maneira: [`MenuItem`](/api/menu-item/) > [`ListItem`](/api/list-item/) > [`ButtonBase`](/api/button-base/).\n\n### Propriedades nativas\n\nEvitamos documentar propriedades nativas suportadas pelo DOM como [`className`](/customization/components/#overriding-styles-with-class-names).\n\n### Classes CSS\n\nTodos os componentes aceitam propriedades [`classes`](/customization/components/#overriding-styles-with-classes) para customizar os estilos. O design de classes responde a duas restrições: para tornar a estrutura das classes o mais simples possível, enquanto suficiente, implementa a especificação de Material Design.\n\n- A classe aplicada ao elemento raiz é sempre chamada de `root`.\n- Todos os estilos padrão são agrupados em uma única classe.\n- As classes aplicadas a elementos não-raiz são prefixadas com o nome do elemento, por exemplo, `paperWidthXs` no componente Dialog.\n- As variantes aplicadas por uma propriedade booleana **não são** prefixadas, por exemplo, a classe `rounded` aplicada pela propriedade `rounded`.\n- As variantes aplicadas por uma propriedade enum **são** prefixadas, por exemplo, a classe `colorPrimary` aplicada pela propriedade `color=\"primary\"`.\n- Uma variante tem **um nível de especificidade**. As propriedades `color` e `variant` são consideradas uma variante. Quanto menor a especificidade de estilo, mais simples é sobrescrever.\n- Aumentamos a especificidade de um modificador variante. Nós já **temos que fazer isso** para as pseudo-classes (`:hover`, `:focus`, etc.). Permite muito mais controle ao custo de mais clichê. Esperamos que também seja mais intuitivo.\n\n```js\nconst styles = {\n  root: {\n    color: green[600],\n    '&$checked': {\n      color: green[500],\n    },\n  },\n  checked: {},\n};\n```\n\n### Componentes aninhados\n\nOs componentes aninhados dentro de um componente possuem:\n\n- suas próprias propriedades niveladas quando estas são chaves para a abstração do componente de nível superior, por exemplo a propriedade `id` para o componente `input`.\n- suas próprias propriedades `xxxProps`, quando os usuários podem precisar ajustar os subcomponentes do método de renderização interno, por exemplo, expondo as propriedades `inputProps` e `InputProps` em componentes que usam `Input` internamente.\n- suas próprias propriedades `xxxComponent` para executar a injeção de componentes.\n- suas próprias propriedades `xxxRef`, quando o usuário precisar executar ações imperativas, por exemplo, expondo uma propriedade `inputRef` para acessar nativamente a `entrada` no componente `Input`. Isso ajuda a responder a pergunta [\"Como posso acessar o elemento DOM?\"](/getting-started/faq/#how-can-i-access-the-dom-element)\n\n### Nomeando propriedades\n\nO nome de uma propriedade booleana deve ser escolhido com base no **valor padrão**. Por exemplo, o atributo `disabled` em um elemento de entrada, se fornecido, é padronizado para `true`. Essa escolha permite a notação abreviada:\n\n```diff\n-<Input enabled={false} />\n+<Input disabled />\n```\n\n### Componentes controlados\n\nA maior parte de componentes controlados, é controlado pelas propriedades `value` e `onChange`, no entanto, o `open` / `onClose` / `onOpen` é uma combinação usada para o estado relacionado à exibição.\n\n### boolean vs enum\n\nExistem duas opções para projetar a API para as variações de um componente: com um *boolean*; ou com um *enum*. Por exemplo, vamos pegar um botão que tenha tipos diferentes. Cada opção tem seus prós e contras:\n\n- Opção 1 *boolean*:\n    \n    ```tsx\n    type Props = {\n    contained: boolean;\n    fab: boolean;\n    };\n    ```\n    \n    Esta API ativou a notação abreviada: `<Button>`, `<Button contained />`, `<Button fab />`.\n\n- Opção 2 *enum*:\n    \n    ```tsx\n    type Props = {\n      variant: 'text' | 'contained' | 'fab';\n    }\n    ```\n    \n    Esta API é mais verbosa: `<Button>`, `<Button variant=\"contained\">`, `<Button variant=\"fab\">`.\n    \n    No entanto, isso impede que uma combinação inválida seja usada, limita o número de propriedades expostas, e pode facilmente suportar novos valores no futuro.\n\nOs componentes de Material-UI usam uma combinação das duas abordagens de acordo com as seguintes regras:\n\n- Um *boolean* é usado quando **2** opções de configuração são necessárias.\n- Um *enum* é usado quando **> 2** opções de configuração são necessárias, ou se houver a possibilidade de futuramente, ser necessários a adição de mais opções.\n\nVoltando ao exemplo do botão anterior; ele requer 3 opções de configuração, nesse caso, usamos um *enum*.\n\n### Ref\n\nO `ref` é encaminhado para o elemento raiz. Isso significa que, sem alterar o elemento raiz renderizado através da propriedade `component`, ele é encaminhado para o elemento DOM mais externo para que o componente renderize. Se você passar um componente diferente através da propriedade `component` o ref será anexado para esse componente.\n\n## Glossário\n\n- **componente hospedeiro**: um tipo de nó DOM no contexto de `react-dom`, por exemplo, um `'div'`. Veja também as [Notas de implementação do React](https://reactjs.org/docs/implementation-notes.html#mounting-host-elements).\n- **elemento hospedeiro**: um nó DOM no contexto de `react-dom`, por exemplo, uma instância de `window.HTMLDivElement`.\n- **mais externo**: O primeiro componente ao ler a árvore de componentes de cima para baixo, ou seja, busca em largura (breadth-first search).\n- **componente raiz**: o componente mais externo que renderiza um componente do hospedeiro.\n- **elemento raiz**: o elemento mais externo que renderiza um componente hospedeiro."