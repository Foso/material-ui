module.exports = "# TypeScript\n\n<p class=\"description\">Sie können statische Typisierung zu JavaScript hinzufügen, um die Produktivität und die Codequalität dank TypeScript zu verbessern.</p>\n\nSchauen Sie sich das [Create React App mit TypeScript](https://github.com/Foso/material-ui/tree/master/examples/create-react-app-with-typescript) Beispiel an. Eine Mindestversion von TypeScript 2.8 ist erforderlich.\n\nIn order for types to work, you have to at least have the following options enabled in your `tsconfig.json`:\n\n```json\n{\n  \"compilerOptions\": {\n    \"lib\": [\"es6\", \"dom\"],\n    \"noImplicitAny\": true,\n    \"noImplicitThis\": true,\n    \"strictNullChecks\": true\n  }\n}\n```\n\nThe strict mode options are the same that are required for every types package published in the `@types/` namespace. Verwendung einer weniger strengen `tsconfig.json` oder das Weglassen einiger Bibliotheken kann zu Fehlern führen. To get the best type experience with the types we recommend setting `\"strict\": true`.\n\n## Verwendung von `withStyles`\n\nVerwenden von `withStyles` in TypeScript kann es etwas kniffelig sein, aber es gibt einige Hilfsprogramme, um die Erfahrung so schmerzlos wie möglich zu gestalten.\n\n### Verwenden von `CreateStyles`, um die Typerweiterung zu besiegen\n\nEine häufige Quelle der Verwirrung ist die [Erweiterung der Typen](https://mariusschulz.com/blog/typescript-2-1-literal-type-widening) von TypeScript, was dazu führt, dass dieses Beispiel nicht wie erwartet funktioniert:\n\n```ts\nconst styles = {\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n  }\n};\n\nwithStyles(styles);\n//         ^^^^^^\n//         Typen der Eigenschaft  'flexDirection' sind nicht kompatibel.\n// Der Typ 'string' kann dem Typ '\"-moz-initial\" | \"inherit\" | \"initial\" |\n// \"revert\" | \"unset\" | \"column\" | \"column-reverse\" | \"row\"...'\n// nicht zugewiesen werden.\n```\n\nDas Problem ist, dass der Typ der `flexDirection` als `string` interpretiert wird, was zu ungenau ist. Um dies zu beheben, können Sie das Styles-Objekt direkt an `withStyles`: übergeben:\n\n```ts\nwithStyles({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n  },\n});\n```\n\nWenn Sie jedoch versuchen, die Stile von dem Thema abhängig zu machen, macht Ihnen die Typenerweiterung wieder eine Strich durch die Rechnung:\n\n```ts\nwithStyles(({ palette, spacing }) => ({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n    padding: spacing.unit,\n    backgroundColor: palette.background.default,\n    color: palette.primary.main,\n  },\n}));\n```\n\nDies liegt daran, dass TypeScript [die Rückgabetypen von Funktionsausdrücken ](https://github.com/Microsoft/TypeScript/issues/241) erweitert.\n\nBecause of this, using the `createStyles` helper function to construct your style rules object is recommended:\n\n```ts\n// Non-dependent styles\nconst styles = createStyles({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n  },\n});\n\n// Theme-dependent styles\nconst styles = ({ palette, spacing }: Theme) => createStyles({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n    padding: spacing.unit,\n    backgroundColor: palette.background.default,\n    color: palette.primary.main,\n  },\n});\n```\n\n`createStyles` ist nur die Identitätsfunktion; es \"tut\" nichts zur Laufzeit, es hilft nur die Typen zur Kompilierzeit festzulegen.\n\n### Media-Anfragen\n\n`withStyles` erlaubt ein Styles-Objekt mit Top-Level-Media-Abfragen wie:\n\n```ts\nconst styles = createStyles({\n  root: {\n    minHeight: '100vh',\n  },\n  '@media (min-width: 960px)': {\n    root: {\n      display: 'flex',\n    },\n  },\n});\n```\n\nDamit diese Stile an TypeScript übergeben werden können, müssen die Definitionen hinsichtlich der Namen der CSS-Klassen und der tatsächlichen CSS-Eigenschaftsnamen mehrdeutig sein. Aus diesem Grund sollten Klassennamen, die den CSS-Eigenschaften entsprechen, vermieden werden.\n\n```ts\n// Fehler, da TypeScript denkte, dass `@media (min-width: 960px)` ein Klassen-\n// name und `content` eine css Eigenschaft ist\nconst ambiguousStyles = createStyles({\n  content: {\n    minHeight: '100vh',\n  },\n  '@media (min-width: 960px)': {\n    content: {\n      display: 'flex',\n    },\n  },\n});\n\n// Dies funktioniert\nconst ambiguousStyles = createStyles({\n  contentClass: {\n    minHeight: '100vh',\n  },\n  '@media (min-width: 960px)': {\n    contentClass: {\n      display: 'flex',\n    },\n  },\n});\n```\n\n### Erweitern Sie Ihre Eigenschaften mit `WithStyles`\n\nDa, wenn eine Komponente mit `withStyles(styles)` dekoriert ist, eine spezielle `classes` Eigenschaft injiziert bekommt, möchten Sie die Eigenschaften entsprechend definieren:\n\n```ts\nconst styles = (theme: Theme) => createStyles({\n  root: { /* ... */ },\n  paper: { /* ... */ },\n  button: { /* ... */ },\n});\n\ninterface Props {\n  // Nicht style Eigenschaften\n  foo: number;\n  bar: boolean;\n  // Injizierte Style Eigenschaften\n  classes: {\n    root: string;\n    paper: string;\n    button: string;\n  };\n}\n```\n\nDies ist jedoch nicht sehr [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) weil Sie die Klassennamen (`'root'`, `'paper'`, `'button'`, ...) an zwei verschiedenen Stellen pflegen müssen. Wir stellen einen Typoperator `WithStyles` bereit, um damit zu helfen. So kannst du einfach schreiben:\n\n```ts\nimport { WithStyles, createStyles } from '@material-ui/core';\n\nconst styles = (theme: Theme) => createStyles({\n  root: { /* ... */ },\n  paper: { /* ... */ },\n  button: { /* ... */ },\n});\n\ninterface Props extends WithStyles<typeof styles> {\n  foo: number;\n  bar: boolean;\n}\n```\n\n### Komponenten dekorieren\n\nAnwenden von `withStyles(styles)` als Funktion funktioniert wie erwartet:\n\n```tsx\nconst DecoratedSFC = withStyles(styles)(({ text, type, color, classes }: Props) => (\n  <Typography variant={type} color={color} classes={classes}>\n    {text}\n  </Typography>\n));\n\nconst DecoratedClass = withStyles(styles)(\n  class extends React.Component<Props> {\n    render() {\n      const { text, type, color, classes } = this.props\n      return (\n        <Typography variant={type} color={color} classes={classes}>\n          {text}\n        </Typography>\n      );\n    }\n  }\n);\n```\n\nAufgrund einer [aktuellen Einschränkung der TypeScript-Dekorateure](https://github.com/Microsoft/TypeScript/issues/4881), kann `withStyles(styles)` leider nicht als Dekorator in TypeScript verwendet werden.\n\n## Anpassung des `Theme`\n\nBeim Hinzufügen benutzerdefinierter Eigenschaften zum `Theme` können Sie es weiterhin in stark typisierter Weise verwenden, indem Sie die [Modulerweiterung von TypeScript](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation) nutzen.\n\nIm folgenden Beispiel wird eine `appDrawer` Eigenschaft hinzugefügt, welche in das von `material-ui` exportierte Theme eingefügt wird:\n\n```ts\nimport { Theme } from '@material-ui/core/styles/createMuiTheme';\nimport { Breakpoint } from '@material-ui/core/styles/createBreakpoints';\n\ndeclare module '@material-ui/core/styles/createMuiTheme' {\n  interface Theme {\n    appDrawer: {\n      width: React.CSSProperties['width']\n      breakpoint: Breakpoint\n    }\n  }\n  // allow configuration using `createMuiTheme`\n  interface ThemeOptions {\n    appDrawer?: {\n      width?: React.CSSProperties['width']\n      breakpoint?: Breakpoint\n    }\n  }\n}\n```\n\nUnd eine benutzerdefinierte Theme Generierung mit zusätzlichen Standardoptionen:\n\n**./styles/createMyTheme**:\n\n```ts\nimport { createMuiTheme } from '@material-ui/core/styles';\nimport { ThemeOptions } from '@material-ui/core/styles/createMuiTheme';\n\nexport default function createMyTheme(options: ThemeOptions) {\n  return createMuiTheme({\n    appDrawer: {\n      width: 225,\n      breakpoint: 'lg',\n    },\n    ...options,\n  })\n}\n```\n\nDies könnte wie folgt verwendet werden:\n\n```ts\nimport createMyTheme from './styles/createMyTheme';\n\nconst theme = createMyTheme({ appDrawer: { breakpoint: 'md' }});\n```\n\n## Usage of `component` prop\n\nMany Material-UI components allow you to replace their root node via a `component` prop, this will be detailed in the component's API documentation. For example, a Button's root node can be replaced with a React Router's Link, and any additional props that are passed to Button, such as `to`, will be spread to the Link component. For a code example concerning Button and react-router-dom checkout [these demos](/guides/composition/#routing-libraries).\n\nTo be able to use props of such a Material-UI component on their own, props should be used with type arguments. Otherwise, the `component` prop will not be present in the props of the Material-UI component.\n\nThe examples below use `TypographyProps` but the same will work for any component which has props defined with `OverrideProps`.\n\nThe following `CustomComponent` component has the same props as the `Typography` component.\n\n```ts\nfunction CustomComponent(props: TypographyProps<'a', { component: 'a' }>) {\n  /* ... */\n}\n```\n\nNow the `CustomComponent` can be used with a `component` prop which should be set to `'a'`. In addition, the `CustomComponent` will have all props of a `<a>` HTML element. The other props of the `Typography` component will also be present in props of the `CustomComponent`.\n\nIt is possible to have generic `CustomComponent` which will accept any React component, custom and HTML elements.\n\n```ts\nfunction GenericCustomComponent<C extends React.ElementType>(\n  props: TypographyProps<C, { component?: C }>,\n) {\n  /* ... */\n}\n```\n\nNow if the `GenericCustomComponent` will be used with a `component` prop provided, it should also have all props required by the provided component.\n\n```ts\nfunction ThirdPartyComponent({ prop1 } : { prop1: string }) {\n  return <div />\n}\n// ...\n<GenericCustomComponent component={ThirdPartyComponent} prop1=\"some value\" />;\n```\n\nThe `prop1` became required for the `GenericCustomComponent` as the `ThirdPartyComponent` has it as a requirement.\n\nNot every component fully supports any component type you pass in. If you encounter a component that rejects its `component` props in TypeScript please open an issue. There is an ongoing effort to fix this by making component props generic.\n\n## Handling `value` and event handlers\n\nMany components concerned with user input offer a `value` prop or event handlers which include the current `value`. In most situations that `value` is only handled within React which allows it be of any type, such as objects or arrays.\n\nHowever, that type cannot be verified at compile time in situations where it depends on the component's children e.g. for `Select` or `RadioGroup`. This means that the soundest option is to type it as `unknown` and let the developer decide how they want to narrow that type down. We do not offer the possibility to use a generic type in those cases for [the same reasons `event.target` is not generic in React](https://github.com/DefinitelyTyped/DefinitelyTyped/issues/11508#issuecomment-256045682).\n\nThe demos include typed variants that use type casting. It is an acceptable tradeoff because the types are all located in a single file and are very basic. You have to decide for yourself if the same tradeoff is acceptable for you. The library types are be strict by default and loose via opt-in.\n"