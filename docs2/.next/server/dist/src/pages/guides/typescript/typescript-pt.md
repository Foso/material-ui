module.exports = "# TypeScript\n\n<p class=\"description\">Você pode adicionar tipagem estática para o JavaScript para melhorar a produtividade do desenvolvimento e a qualidade do código graças ao TypeScript.</p>\n\nDê uma olhada no exemplo [Create React App com TypeScript](https://github.com/Foso/material-ui/tree/master/examples/create-react-app-with-typescript). É necessário estar no mínimo com a versão 2.8 do TypeScript.\n\nIn order for types to work, you have to at least have the following options enabled in your `tsconfig.json`:\n\n```json\n{\n  \"compilerOptions\": {\n    \"lib\": [\"es6\", \"dom\"],\n    \"noImplicitAny\": true,\n    \"noImplicitThis\": true,\n    \"strictNullChecks\": true\n  }\n}\n```\n\nThe strict mode options are the same that are required for every types package published in the `@types/` namespace. Usando uma `tsconfig.json` menos rigorosa ou omitindo algumas das bibliotecas podem causar erros. To get the best type experience with the types we recommend setting `\"strict\": true`.\n\n## Uso de `withStyles`\n\nUtilizando `withStyles` no TypeScript pode ser um pouco complicado, mas há alguns utilitários que tornam a experiência menos dolorosa possível.\n\n### Utilizando `createStyles` para evitar a ampliação de tipo (type widening)\n\nUma fonte frequente de confusão é a ampliação de tipos ([type widening](https://mariusschulz.com/blog/typescript-2-1-literal-type-widening)) do TypeScript, que faz com que este exemplo não funcione como o esperado:\n\n```ts\nconst styles = {\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n  }\n};\n\nwithStyles(styles);\n//         ^^^^^^\n//         Os tipos de propriedade 'flexDirection' são incompatíveis.\n//           Tipo 'string' não pode ser atribuído para o tipo '\"-moz-initial\" | \"inherit\" | \"initial\" | \"revert\" | \"unset\" | \"column\" | \"column-reverse\" | \"row\"...'.\n```\n\nO problema é que o tipo da propriedade `flexDirection` é convertido como `string`, no qual é o tipo mais conveniente. Para corrigir isto, você pode passar o objeto de estilos diretamente para `withStyles`:\n\n```ts\nwithStyles({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n  },\n});\n```\n\nNo entanto, a ampliação de tipos continuará a causar dores de cabeça se você tentar fazer com que os estilos dependam do tema:\n\n```ts\nwithStyles(({ palette, spacing }) => ({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n    padding: spacing.unit,\n    backgroundColor: palette.background.default,\n    color: palette.primary.main,\n  },\n}));\n```\n\nIsso ocorre pois o TypeScript [amplia o retorno de tipos de expressões de função](https://github.com/Microsoft/TypeScript/issues/241).\n\nBecause of this, using the `createStyles` helper function to construct your style rules object is recommended:\n\n```ts\n// Estilos sem dependência\nconst styles = createStyles({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n  },\n});\n\n// Estilos com dependência do tema\nconst styles = ({ palette, spacing }: Theme) => createStyles({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n    padding: spacing.unit,\n    backgroundColor: palette.background.default,\n    color: palette.primary.main,\n  },\n});\n```\n\n`createStyles` é apenas a identidade da função; ela não \"faz nada\" em tempo de execução, apenas auxilia a inferência de tipos em tempo de compilação.\n\n### Consultas de Mídia (Media queries)\n\n`withStyles` permite utilizar um objeto de estilos de nível superior com consultas de mídia assim:\n\n```ts\nconst styles = createStyles({\n  root: {\n    minHeight: '100vh',\n  },\n  '@media (min-width: 960px)': {\n    root: {\n      display: 'flex',\n    },\n  },\n});\n```\n\nNo entanto, para permitir que estes estilos passem pelo TypeScript, as definições devem ser ambíguas em relação aos nomes de classes CSS e nomes de propriedades CSS. Devido a isso, evite utilizar nomes de classes iguais a propriedades do CSS.\n\n```ts\n// erro porque TypeScript acha que `@media (min-width: 960px)` é o nome da classe\n// e `content` é a propriedade css\nconst ambiguousStyles = createStyles({\n  content: {\n    minHeight: '100vh',\n  },\n  '@media (min-width: 960px)': {\n    content: {\n      display: 'flex',\n    },\n  },\n});\n\n// funciona corretamente\nconst ambiguousStyles = createStyles({\n  contentClass: {\n    minHeight: '100vh',\n  },\n  '@media (min-width: 960px)': {\n    contentClass: {\n      display: 'flex',\n    },\n  },\n});\n```\n\n### Incrementando suas propriedades utilizando `WithStyles`\n\nDesde que um componente seja decorado com `withStyles(styles)`, ele recebe uma propriedade injetada `classes`, você pode querer definir estas propriedades de acordo com:\n\n```ts\nconst styles = (theme: Theme) => createStyles({\n  root: { /* ... */ },\n  paper: { /* ... */ },\n  button: { /* ... */ },\n});\n\ninterface Props {\n  // non-style props\n  foo: number;\n  bar: boolean;\n  // injected style props\n  classes: {\n    root: string;\n    paper: string;\n    button: string;\n  };\n}\n```\n\nNo entanto isto não é muito elegante de acordo com o princípio de software [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself), porque requer que você mantenha os nomes das classes (`'root'`, `'paper'`, `'button'`, ...) em dois locais diferentes. Nós fornecemos um operador de tipo `WithStyles` para ajudar com isso, assim você pode apenas escrever:\n\n```ts\nimport { WithStyles, createStyles } from '@material-ui/core';\n\nconst styles = (theme: Theme) => createStyles({\n  root: { /* ... */ },\n  paper: { /* ... */ },\n  button: { /* ... */ },\n});\n\ninterface Props extends WithStyles<typeof styles> {\n  foo: number;\n  bar: boolean;\n}\n```\n\n### Decorando componentes\n\nAplicando `withStyles(styles)` como uma função, nos dá o resultado como o esperado:\n\n```tsx\nconst DecoratedSFC = withStyles(styles)(({ text, type, color, classes }: Props) => (\n  <Typography variant={type} color={color} classes={classes}>\n    {text}\n  </Typography>\n));\n\nconst DecoratedClass = withStyles(styles)(\n  class extends React.Component<Props> {\n    render() {\n      const { text, type, color, classes } = this.props\n      return (\n        <Typography variant={type} color={color} classes={classes}>\n          {text}\n        </Typography>\n      );\n    }\n  }\n);\n```\n\nInfelizmente devido a uma [limitação atual dos decoradores do TypeScript](https://github.com/Microsoft/TypeScript/issues/4881), `withStyles(styles)` não pode ser usado como decorador no TypeScript.\n\n## Customização de tema\n\nAo adicionar propriedades customizadas ao `Theme`, você pode continuar a utilizá-lo de uma maneira fortemente tipada, explorando o conceito de extensão de módulos do TypeScript ([TypeScript's module augmentation](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation)).\n\nO exemplo a seguir adiciona uma propriedade `appDrawer` que é mesclada na que foi exportada pelo `material-ui`:\n\n```ts\nimport { Theme } from '@material-ui/core/styles/createMuiTheme';\nimport { Breakpoint } from '@material-ui/core/styles/createBreakpoints';\n\ndeclare module '@material-ui/core/styles/createMuiTheme' {\n  interface Theme {\n    appDrawer: {\n      width: React.CSSProperties['width']\n      breakpoint: Breakpoint\n    }\n  }\n  // permitir configuração usando `createMuiTheme`\n  interface ThemeOptions {\n    appDrawer?: {\n      width?: React.CSSProperties['width']\n      breakpoint?: Breakpoint\n    }\n  }\n}\n```\n\nE uma fábrica customizada de temas com opções padrão adicionais:\n\n**./styles/createMyTheme**:\n\n```ts\nimport { createMuiTheme } from '@material-ui/core/styles';\nimport { ThemeOptions } from '@material-ui/core/styles/createMuiTheme';\n\nexport default function createMyTheme(options: ThemeOptions) {\n  return createMuiTheme({\n    appDrawer: {\n      width: 225,\n      breakpoint: 'lg',\n    },\n    ...options,\n  })\n}\n```\n\nIsso poderia ser usado como:\n\n```ts\nimport createMyTheme from './styles/createMyTheme';\n\nconst theme = createMyTheme({ appDrawer: { breakpoint: 'md' }});\n```\n\n## Uso da propriedade `component`\n\nMany Material-UI components allow you to replace their root node via a `component` prop, this will be detailed in the component's API documentation. For example, a Button's root node can be replaced with a React Router's Link, and any additional props that are passed to Button, such as `to`, will be spread to the Link component. For a code example concerning Button and react-router-dom checkout [these demos](/guides/composition/#routing-libraries).\n\nTo be able to use props of such a Material-UI component on their own, props should be used with type arguments. Otherwise, the `component` prop will not be present in the props of the Material-UI component.\n\nThe examples below use `TypographyProps` but the same will work for any component which has props defined with `OverrideProps`.\n\nThe following `CustomComponent` component has the same props as the `Typography` component.\n\n```ts\nfunction CustomComponent(props: TypographyProps<'a', { component: 'a' }>) {\n  /* ... */\n}\n```\n\nNow the `CustomComponent` can be used with a `component` prop which should be set to `'a'`. In addition, the `CustomComponent` will have all props of a `<a>` HTML element. The other props of the `Typography` component will also be present in props of the `CustomComponent`.\n\nIt is possible to have generic `CustomComponent` which will accept any React component, custom and HTML elements.\n\n```ts\nfunction GenericCustomComponent<C extends React.ElementType>(\n  props: TypographyProps<C, { component?: C }>,\n) {\n  /* ... */\n}\n```\n\nNow if the `GenericCustomComponent` will be used with a `component` prop provided, it should also have all props required by the provided component.\n\n```ts\nfunction ThirdPartyComponent({ prop1 } : { prop1: string }) {\n  return <div />\n}\n// ...\n<GenericCustomComponent component={ThirdPartyComponent} prop1=\"some value\" />;\n```\n\nThe `prop1` became required for the `GenericCustomComponent` as the `ThirdPartyComponent` has it as a requirement.\n\nNot every component fully supports any component type you pass in. If you encounter a component that rejects its `component` props in TypeScript please open an issue. There is an ongoing effort to fix this by making component props generic.\n\n## Manipulando `value` e manipuladores de eventos\n\nMany components concerned with user input offer a `value` prop or event handlers which include the current `value`. In most situations that `value` is only handled within React which allows it be of any type, such as objects or arrays.\n\nHowever, that type cannot be verified at compile time in situations where it depends on the component's children e.g. for `Select` or `RadioGroup`. This means that the soundest option is to type it as `unknown` and let the developer decide how they want to narrow that type down. We do not offer the possibility to use a generic type in those cases for [the same reasons `event.target` is not generic in React](https://github.com/DefinitelyTyped/DefinitelyTyped/issues/11508#issuecomment-256045682).\n\nThe demos include typed variants that use type casting. It is an acceptable tradeoff because the types are all located in a single file and are very basic. You have to decide for yourself if the same tradeoff is acceptable for you. The library types are be strict by default and loose via opt-in.\n"