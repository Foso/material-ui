module.exports = "# TypeScript\n\n<p class=\"description\">You can add static typing to JavaScript to improve developer productivity and code quality thanks to TypeScript.</p>\n\nHave a look at the [Create React App with TypeScript](https://github.com/Foso/material-ui/tree/master/examples/create-react-app-with-typescript) example. A minimum version of TypeScript 2.8 is required.\n\nIn order for types to work, you have to at least have the following options enabled\nin your `tsconfig.json`:\n\n```json\n{\n  \"compilerOptions\": {\n    \"lib\": [\"es6\", \"dom\"],\n    \"noImplicitAny\": true,\n    \"noImplicitThis\": true,\n    \"strictNullChecks\": true\n  }\n}\n```\n\nThe strict mode options are the same that are required for every types package\npublished in the `@types/` namespace. Using a less strict `tsconfig.json` or omitting some of the libraries might cause errors. To get the best type experience with the types we recommend\nsetting `\"strict\": true`.\n\n## Usage of `withStyles`\n\nUsing `withStyles` in TypeScript can be a little tricky, but there are some utilities to make the experience as painless as possible.\n\n### Using `createStyles` to defeat type widening\n\nA frequent source of confusion is TypeScript's [type widening](https://mariusschulz.com/blog/typescript-2-1-literal-type-widening), which causes this example not to work as expected:\n\n```ts\nconst styles = {\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n  }\n};\n\nwithStyles(styles);\n//         ^^^^^^\n//         Types of property 'flexDirection' are incompatible.\n//           Type 'string' is not assignable to type '\"-moz-initial\" | \"inherit\" | \"initial\" | \"revert\" | \"unset\" | \"column\" | \"column-reverse\" | \"row\"...'.\n```\n\nThe problem is that the type of the `flexDirection` property is inferred as `string`, which is too arbitrary. To fix this, you can pass the styles object directly to `withStyles`:\n\n```ts\nwithStyles({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n  },\n});\n```\n\nHowever type widening rears its ugly head once more if you try to make the styles depend on the theme:\n\n```ts\nwithStyles(({ palette, spacing }) => ({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n    padding: spacing.unit,\n    backgroundColor: palette.background.default,\n    color: palette.primary.main,\n  },\n}));\n```\n\nThis is because TypeScript [widens the return types of function expressions](https://github.com/Microsoft/TypeScript/issues/241).\n\nBecause of this, using the `createStyles` helper function to construct your style rules object is recommended:\n\n```ts\n// Non-dependent styles\nconst styles = createStyles({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n  },\n});\n\n// Theme-dependent styles\nconst styles = ({ palette, spacing }: Theme) => createStyles({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n    padding: spacing.unit,\n    backgroundColor: palette.background.default,\n    color: palette.primary.main,\n  },\n});\n```\n\n`createStyles` is just the identity function; it doesn't \"do anything\" at runtime, just helps guide type inference at compile time.\n\n### Media queries\n\n`withStyles` allows a styles object with top level media-queries like so:\n\n```ts\nconst styles = createStyles({\n  root: {\n    minHeight: '100vh',\n  },\n  '@media (min-width: 960px)': {\n    root: {\n      display: 'flex',\n    },\n  },\n});\n```\n\nHowever to allow these styles to pass TypeScript, the definitions have to be ambiguous concerning names for CSS classes and actual CSS property names. Due to this class names that are equal to CSS properties should be avoided.\n\n```ts\n// error because TypeScript thinks `@media (min-width: 960px)` is a class name\n// and `content` is the css property\nconst ambiguousStyles = createStyles({\n  content: {\n    minHeight: '100vh',\n  },\n  '@media (min-width: 960px)': {\n    content: {\n      display: 'flex',\n    },\n  },\n});\n\n// works just fine\nconst ambiguousStyles = createStyles({\n  contentClass: {\n    minHeight: '100vh',\n  },\n  '@media (min-width: 960px)': {\n    contentClass: {\n      display: 'flex',\n    },\n  },\n});\n```\n\n### Augmenting your props using `WithStyles`\n\nSince a component decorated with `withStyles(styles)` gets a special `classes` prop injected, you will want to define its props accordingly:\n\n```ts\nconst styles = (theme: Theme) => createStyles({\n  root: { /* ... */ },\n  paper: { /* ... */ },\n  button: { /* ... */ },\n});\n\ninterface Props {\n  // non-style props\n  foo: number;\n  bar: boolean;\n  // injected style props\n  classes: {\n    root: string;\n    paper: string;\n    button: string;\n  };\n}\n```\n\nHowever this isn't very [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) because it requires you to maintain the class names (`'root'`, `'paper'`, `'button'`, ...) in two different places. We provide a type operator `WithStyles` to help with this, so that you can just write:\n\n```ts\nimport { WithStyles, createStyles } from '@material-ui/core';\n\nconst styles = (theme: Theme) => createStyles({\n  root: { /* ... */ },\n  paper: { /* ... */ },\n  button: { /* ... */ },\n});\n\ninterface Props extends WithStyles<typeof styles> {\n  foo: number;\n  bar: boolean;\n}\n```\n\n### Decorating components\n\nApplying `withStyles(styles)` as a function works as expected:\n\n```tsx\nconst DecoratedSFC = withStyles(styles)(({ text, type, color, classes }: Props) => (\n  <Typography variant={type} color={color} classes={classes}>\n    {text}\n  </Typography>\n));\n\nconst DecoratedClass = withStyles(styles)(\n  class extends React.Component<Props> {\n    render() {\n      const { text, type, color, classes } = this.props\n      return (\n        <Typography variant={type} color={color} classes={classes}>\n          {text}\n        </Typography>\n      );\n    }\n  }\n);\n```\n\nUnfortunately due to a [current limitation of TypeScript decorators](https://github.com/Microsoft/TypeScript/issues/4881), `withStyles(styles)` can't be used as a decorator in TypeScript.\n\n## Customization of `Theme`\n\nWhen adding custom properties to the `Theme`, you may continue to use it in a strongly typed way by exploiting\n[TypeScript's module augmentation](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation).\n\nThe following example adds an `appDrawer` property that is merged into the one exported by `material-ui`:\n\n```ts\nimport { Theme } from '@material-ui/core/styles/createMuiTheme';\nimport { Breakpoint } from '@material-ui/core/styles/createBreakpoints';\n\ndeclare module '@material-ui/core/styles/createMuiTheme' {\n  interface Theme {\n    appDrawer: {\n      width: React.CSSProperties['width']\n      breakpoint: Breakpoint\n    }\n  }\n  // allow configuration using `createMuiTheme`\n  interface ThemeOptions {\n    appDrawer?: {\n      width?: React.CSSProperties['width']\n      breakpoint?: Breakpoint\n    }\n  }\n}\n```\n\nAnd a custom theme factory with additional defaulted options:\n\n**./styles/createMyTheme**:\n```ts\nimport { createMuiTheme, ThemeOptions } from '@material-ui/core/styles';\n\nexport default function createMyTheme(options: ThemeOptions) {\n  return createMuiTheme({\n    appDrawer: {\n      width: 225,\n      breakpoint: 'lg',\n    },\n    ...options,\n  })\n}\n```\n\nThis could be used like:\n\n```ts\nimport createMyTheme from './styles/createMyTheme';\n\nconst theme = createMyTheme({ appDrawer: { breakpoint: 'md' }});\n```\n\n## Usage of `component` prop\n\nMany Material-UI components allow you to replace their root node via a `component`\nprop, this will be detailed in the component's API documentation.\nFor example, a Button's root node can be replaced with a React Router's Link, and any additional props that are passed to Button, such as `to`, will be spread to the Link component.\nFor a code example concerning Button and react-router-dom checkout [these demos](/guides/composition/#routing-libraries).\n\nTo be able to use props of such a Material-UI component on their own, props should be used with type arguments. Otherwise, the `component` prop will not be present in the props of the Material-UI component.\n\nThe examples below use `TypographyProps` but the same will work for any component which has props defined with `OverrideProps`.\n\nThe following `CustomComponent` component has the same props as the `Typography` component.\n\n```ts\nfunction CustomComponent(props: TypographyProps<'a', { component: 'a' }>) {\n  /* ... */\n}\n```\n\nNow the `CustomComponent` can be used with a `component` prop which should be set to `'a'`. In addition, the `CustomComponent` will have all props of a `<a>` HTML element. The other props of the `Typography` component will also be present in props of the `CustomComponent`.\n\nIt is possible to have generic `CustomComponent` which will accept any React component, custom and HTML elements.\n\n```ts\nfunction GenericCustomComponent<C extends React.ElementType>(\n  props: TypographyProps<C, { component?: C }>,\n) {\n  /* ... */\n}\n```\n\nNow if the `GenericCustomComponent` will be used with a `component` prop provided, it should also have all props required by the provided component.\n\n```ts\nfunction ThirdPartyComponent({ prop1 } : { prop1: string }) {\n  return <div />\n}\n// ...\n<GenericCustomComponent component={ThirdPartyComponent} prop1=\"some value\" />;\n```\n\nThe `prop1` became required for the `GenericCustomComponent` as the `ThirdPartyComponent` has it as a requirement.\n\nNot every component fully supports any component type you pass in. If you encounter a component that rejects its `component` props in TypeScript please open an issue.\nThere is an ongoing effort to fix this by making component props generic.\n\n## Handling `value` and event handlers\n\nMany components concerned with user input offer a `value` prop or event handlers\nwhich include the current `value`. In most situations that `value` is only handled\nwithin React which allows it be of any type, such as objects or arrays.\n\nHowever, that type cannot be verified at compile time in situations where it depends\non the component's children e.g. for `Select` or `RadioGroup`. This means that\nthe soundest option is to type it as `unknown` and let the developer decide\nhow they want to narrow that type down. We do not offer the possibility to use a generic\ntype in those cases for [the same reasons `event.target` is not generic in React](https://github.com/DefinitelyTyped/DefinitelyTyped/issues/11508#issuecomment-256045682).\n\nThe demos include typed variants that use type casting. It is an acceptable tradeoff\nbecause the types are all located in a single file and are very basic. You have to decide for yourself\nif the same tradeoff is acceptable for you. The library types are be strict\nby default and loose via opt-in.\n"