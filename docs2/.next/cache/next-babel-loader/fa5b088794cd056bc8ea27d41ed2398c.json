{"ast":null,"code":"import _extends from \"@babel/runtime-corejs2/helpers/esm/extends\";\nimport _objectSpread from \"@babel/runtime-corejs2/helpers/esm/objectSpread2\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _Array$isArray from \"@babel/runtime-corejs2/core-js/array/is-array\";\nimport _objectWithoutProperties from \"@babel/runtime-corejs2/helpers/esm/objectWithoutProperties\";\nvar __jsx = React.createElement;\nimport * as React from 'react';\nimport clsx from 'clsx';\nimport TreeViewContext from \"./TreeViewContext\";\nimport { withStyles } from \"../../../material-ui/src/styles\";\nimport { useControlled } from \"../../../material-ui/src/utils\";\nexport const styles = {\n  /* Styles applied to the root element. */\n  root: {\n    padding: 0,\n    margin: 0,\n    listStyle: 'none'\n  }\n};\n\nfunction arrayDiff(arr1, arr2) {\n  if (arr1.length !== arr2.length) return true;\n\n  for (let i = 0; i < arr1.length; i += 1) {\n    if (arr1[i] !== arr2[i]) return true;\n  }\n\n  return false;\n}\n\nconst findNextFirstChar = (firstChars, startIndex, char) => {\n  for (let i = startIndex; i < firstChars.length; i += 1) {\n    if (char === firstChars[i]) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n\nconst defaultExpandedDefault = [];\nconst defaultSelectedDefault = [];\nconst TreeView = React.forwardRef(function TreeView(props, ref) {\n  const {\n    children,\n    classes,\n    className,\n    defaultCollapseIcon,\n    defaultEndIcon,\n    defaultExpanded = defaultExpandedDefault,\n    defaultExpandIcon,\n    defaultParentIcon,\n    defaultSelected = defaultSelectedDefault,\n    disableSelection = false,\n    multiSelect = false,\n    expanded: expandedProp,\n    onNodeSelect,\n    onNodeToggle,\n    selected: selectedProp\n  } = props,\n        other = _objectWithoutProperties(props, [\"children\", \"classes\", \"className\", \"defaultCollapseIcon\", \"defaultEndIcon\", \"defaultExpanded\", \"defaultExpandIcon\", \"defaultParentIcon\", \"defaultSelected\", \"disableSelection\", \"multiSelect\", \"expanded\", \"onNodeSelect\", \"onNodeToggle\", \"selected\"]);\n\n  const [tabbable, setTabbable] = React.useState(null);\n  const [focused, setFocused] = React.useState(null);\n  const nodeMap = React.useRef({});\n  const firstCharMap = React.useRef({});\n  const visibleNodes = React.useRef([]);\n  const [expanded, setExpandedState] = useControlled({\n    controlled: expandedProp,\n    default: defaultExpanded,\n    name: 'TreeView'\n  });\n  const [selected, setSelectedState] = useControlled({\n    controlled: selectedProp,\n    default: defaultSelected,\n    name: 'TreeView'\n  });\n  /*\n   * Status Helpers\n   */\n\n  const isExpanded = React.useCallback(id => _Array$isArray(expanded) ? expanded.indexOf(id) !== -1 : false, [expanded]);\n  const isSelected = React.useCallback(id => _Array$isArray(selected) ? selected.indexOf(id) !== -1 : selected === id, [selected]);\n\n  const isTabbable = id => tabbable === id;\n\n  const isFocused = id => focused === id;\n  /*\n   * Node Helpers\n   */\n\n\n  const getNextNode = id => {\n    const nodeIndex = visibleNodes.current.indexOf(id);\n\n    if (nodeIndex !== -1 && nodeIndex + 1 < visibleNodes.current.length) {\n      return visibleNodes.current[nodeIndex + 1];\n    }\n\n    return null;\n  };\n\n  const getPreviousNode = id => {\n    const nodeIndex = visibleNodes.current.indexOf(id);\n\n    if (nodeIndex !== -1 && nodeIndex - 1 >= 0) {\n      return visibleNodes.current[nodeIndex - 1];\n    }\n\n    return null;\n  };\n\n  const getLastNode = () => visibleNodes.current[visibleNodes.current.length - 1];\n\n  const getFirstNode = () => visibleNodes.current[0];\n\n  const getParent = id => nodeMap.current[id].parent;\n\n  const getNodesInRange = (a, b) => {\n    const aIndex = visibleNodes.current.indexOf(a);\n    const bIndex = visibleNodes.current.indexOf(b);\n    const start = Math.min(aIndex, bIndex);\n    const end = Math.max(aIndex, bIndex);\n    return visibleNodes.current.slice(start, end + 1);\n  };\n  /*\n   * Focus Helpers\n   */\n\n\n  const focus = id => {\n    if (id) {\n      setTabbable(id);\n      setFocused(id);\n    }\n  };\n\n  const focusNextNode = id => focus(getNextNode(id));\n\n  const focusPreviousNode = id => focus(getPreviousNode(id));\n\n  const focusFirstNode = () => focus(getFirstNode());\n\n  const focusLastNode = () => focus(getLastNode());\n\n  const focusByFirstCharacter = (id, char) => {\n    let start;\n    let index;\n    const lowercaseChar = char.toLowerCase();\n    const firstCharIds = [];\n    const firstChars = []; // This really only works since the ids are strings\n\n    _Object$keys(firstCharMap.current).forEach(nodeId => {\n      const firstChar = firstCharMap.current[nodeId];\n      const map = nodeMap.current[nodeId];\n      const visible = map.parent ? isExpanded(map.parent) : true;\n\n      if (visible) {\n        firstCharIds.push(nodeId);\n        firstChars.push(firstChar);\n      }\n    }); // Get start index for search based on position of currentItem\n\n\n    start = firstCharIds.indexOf(id) + 1;\n\n    if (start === nodeMap.current.length) {\n      start = 0;\n    } // Check remaining slots in the menu\n\n\n    index = findNextFirstChar(firstChars, start, lowercaseChar); // If not found in remaining slots, check from beginning\n\n    if (index === -1) {\n      index = findNextFirstChar(firstChars, 0, lowercaseChar);\n    } // If match was found...\n\n\n    if (index > -1) {\n      focus(firstCharIds[index]);\n    }\n  };\n  /*\n   * Expansion Helpers\n   */\n\n\n  const toggleExpansion = (event, value = focused) => {\n    let newExpanded;\n\n    if (expanded.indexOf(value) !== -1) {\n      newExpanded = expanded.filter(id => id !== value);\n      setTabbable(oldTabbable => {\n        const map = nodeMap.current[oldTabbable];\n\n        if (oldTabbable && (map && map.parent ? map.parent.id : null) === value) {\n          return value;\n        }\n\n        return oldTabbable;\n      });\n    } else {\n      newExpanded = [value, ...expanded];\n    }\n\n    if (onNodeToggle) {\n      onNodeToggle(event, newExpanded);\n    }\n\n    setExpandedState(newExpanded);\n  };\n\n  const expandAllSiblings = (event, id) => {\n    const map = nodeMap.current[id];\n    const parent = nodeMap.current[map.parent];\n    let diff;\n\n    if (parent) {\n      diff = parent.children.filter(child => !isExpanded(child));\n    } else {\n      const topLevelNodes = nodeMap.current[-1].children;\n      diff = topLevelNodes.filter(node => !isExpanded(node));\n    }\n\n    const newExpanded = [...expanded, ...diff];\n    setExpandedState(newExpanded);\n\n    if (onNodeToggle) {\n      onNodeToggle(event, newExpanded);\n    }\n  };\n  /*\n   * Selection Helpers\n   */\n\n\n  const lastSelectedNode = React.useRef(null);\n  const lastSelectionWasRange = React.useRef(false);\n  const currentRangeSelection = React.useRef([]);\n\n  const handleRangeArrowSelect = (event, nodes) => {\n    let base = selected;\n    const {\n      start,\n      next,\n      current\n    } = nodes;\n\n    if (!next || !current) {\n      return;\n    }\n\n    if (currentRangeSelection.current.indexOf(current) === -1) {\n      currentRangeSelection.current = [];\n    }\n\n    if (lastSelectionWasRange.current) {\n      if (currentRangeSelection.current.indexOf(next) !== -1) {\n        base = base.filter(id => id === start || id !== current);\n        currentRangeSelection.current = currentRangeSelection.current.filter(id => id === start || id !== current);\n      } else {\n        base.push(next);\n        currentRangeSelection.current.push(next);\n      }\n    } else {\n      base.push(next);\n      currentRangeSelection.current.push(current, next);\n    }\n\n    if (onNodeSelect) {\n      onNodeSelect(event, base);\n    }\n\n    setSelectedState(base);\n  };\n\n  const handleRangeSelect = (event, nodes) => {\n    let base = selected;\n    const {\n      start,\n      end\n    } = nodes; // If last selection was a range selection ignore nodes that were selected.\n\n    if (lastSelectionWasRange.current) {\n      base = selected.filter(id => currentRangeSelection.current.indexOf(id) === -1);\n    }\n\n    const range = getNodesInRange(start, end);\n    currentRangeSelection.current = range;\n    let newSelected = base.concat(range);\n    newSelected = newSelected.filter((id, i) => newSelected.indexOf(id) === i);\n\n    if (onNodeSelect) {\n      onNodeSelect(event, newSelected);\n    }\n\n    setSelectedState(newSelected);\n  };\n\n  const handleMultipleSelect = (event, value) => {\n    let newSelected = [];\n\n    if (selected.indexOf(value) !== -1) {\n      newSelected = selected.filter(id => id !== value);\n    } else {\n      newSelected = [value, ...selected];\n    }\n\n    if (onNodeSelect) {\n      onNodeSelect(event, newSelected);\n    }\n\n    setSelectedState(newSelected);\n  };\n\n  const handleSingleSelect = (event, value) => {\n    const newSelected = multiSelect ? [value] : value;\n\n    if (onNodeSelect) {\n      onNodeSelect(event, newSelected);\n    }\n\n    setSelectedState(newSelected);\n  };\n\n  const selectNode = (event, id, multiple = false) => {\n    if (id) {\n      if (multiple) {\n        handleMultipleSelect(event, id);\n      } else {\n        handleSingleSelect(event, id);\n      }\n\n      lastSelectedNode.current = id;\n      lastSelectionWasRange.current = false;\n      currentRangeSelection.current = [];\n    }\n  };\n\n  const selectRange = (event, nodes, stacked = false) => {\n    const {\n      start = lastSelectedNode.current,\n      end,\n      current\n    } = nodes;\n\n    if (stacked) {\n      handleRangeArrowSelect(event, {\n        start,\n        next: end,\n        current\n      });\n    } else {\n      handleRangeSelect(event, {\n        start,\n        end\n      });\n    }\n\n    lastSelectionWasRange.current = true;\n  };\n\n  const rangeSelectToFirst = (event, id) => {\n    if (!lastSelectedNode.current) {\n      lastSelectedNode.current = id;\n    }\n\n    const start = lastSelectionWasRange.current ? lastSelectedNode.current : id;\n    selectRange(event, {\n      start,\n      end: getFirstNode()\n    });\n  };\n\n  const rangeSelectToLast = (event, id) => {\n    if (!lastSelectedNode.current) {\n      lastSelectedNode.current = id;\n    }\n\n    const start = lastSelectionWasRange.current ? lastSelectedNode.current : id;\n    selectRange(event, {\n      start,\n      end: getLastNode()\n    });\n  };\n\n  const selectNextNode = (event, id) => selectRange(event, {\n    end: getNextNode(id),\n    current: id\n  }, true);\n\n  const selectPreviousNode = (event, id) => selectRange(event, {\n    end: getPreviousNode(id),\n    current: id\n  }, true);\n\n  const selectAllNodes = event => selectRange(event, {\n    start: getFirstNode(),\n    end: getLastNode()\n  });\n  /*\n   * Mapping Helpers\n   */\n\n\n  const addNodeToNodeMap = (id, childrenIds) => {\n    const currentMap = nodeMap.current[id];\n    nodeMap.current[id] = _objectSpread({}, currentMap, {\n      children: childrenIds,\n      id\n    });\n    childrenIds.forEach(childId => {\n      const currentChildMap = nodeMap.current[childId];\n      nodeMap.current[childId] = _objectSpread({}, currentChildMap, {\n        parent: id,\n        id: childId\n      });\n    });\n  };\n\n  const getNodesToRemove = React.useCallback(id => {\n    const map = nodeMap.current[id];\n    const nodes = [];\n\n    if (map) {\n      nodes.push(id);\n\n      if (map.children) {\n        nodes.push(...map.children);\n        map.children.forEach(node => {\n          nodes.push(...getNodesToRemove(node));\n        });\n      }\n    }\n\n    return nodes;\n  }, []);\n  const removeNodeFromNodeMap = React.useCallback(id => {\n    const nodes = getNodesToRemove(id);\n\n    const newMap = _objectSpread({}, nodeMap.current);\n\n    nodes.forEach(node => {\n      const map = newMap[node];\n\n      if (map) {\n        if (map.parent) {\n          const parentMap = newMap[map.parent];\n\n          if (parentMap && parentMap.children) {\n            const parentChildren = parentMap.children.filter(c => c !== node);\n            newMap[map.parent] = _objectSpread({}, parentMap, {\n              children: parentChildren\n            });\n          }\n        }\n\n        delete newMap[node];\n      }\n    });\n    nodeMap.current = newMap;\n  }, [getNodesToRemove]);\n\n  const mapFirstChar = (id, firstChar) => {\n    firstCharMap.current[id] = firstChar;\n  };\n\n  const prevChildIds = React.useRef([]);\n  const [childrenCalculated, setChildrenCalculated] = React.useState(false);\n  React.useEffect(() => {\n    const childIds = [];\n    React.Children.forEach(children, child => {\n      if (React.isValidElement(child) && child.props.nodeId) {\n        childIds.push(child.props.nodeId);\n      }\n    });\n\n    if (arrayDiff(prevChildIds.current, childIds)) {\n      nodeMap.current[-1] = {\n        parent: null,\n        children: childIds\n      };\n      childIds.forEach((id, index) => {\n        if (index === 0) {\n          setTabbable(id);\n        }\n\n        nodeMap.current[id] = {\n          parent: null\n        };\n      });\n      visibleNodes.current = nodeMap.current[-1].children;\n      prevChildIds.current = childIds;\n      setChildrenCalculated(true);\n    }\n  }, [children]);\n  React.useEffect(() => {\n    const buildVisible = nodes => {\n      let list = [];\n\n      for (let i = 0; i < nodes.length; i += 1) {\n        const item = nodes[i];\n        list.push(item);\n        const childs = nodeMap.current[item].children;\n\n        if (isExpanded(item) && childs) {\n          list = list.concat(buildVisible(childs));\n        }\n      }\n\n      return list;\n    };\n\n    if (childrenCalculated) {\n      visibleNodes.current = buildVisible(nodeMap.current[-1].children);\n    }\n  }, [expanded, childrenCalculated, isExpanded]);\n  return __jsx(TreeViewContext.Provider, {\n    value: {\n      icons: {\n        defaultCollapseIcon,\n        defaultExpandIcon,\n        defaultParentIcon,\n        defaultEndIcon\n      },\n      focus,\n      focusFirstNode,\n      focusLastNode,\n      focusNextNode,\n      focusPreviousNode,\n      focusByFirstCharacter,\n      expandAllSiblings,\n      toggleExpansion,\n      isExpanded,\n      isFocused,\n      isSelected,\n      selectNode,\n      selectRange,\n      selectNextNode,\n      selectPreviousNode,\n      rangeSelectToFirst,\n      rangeSelectToLast,\n      selectAllNodes,\n      isTabbable,\n      multiSelect,\n      selectionDisabled: disableSelection,\n      getParent,\n      mapFirstChar,\n      addNodeToNodeMap,\n      removeNodeFromNodeMap\n    }\n  }, __jsx(\"ul\", _extends({\n    role: \"tree\",\n    \"aria-multiselectable\": multiSelect,\n    className: clsx(classes.root, className),\n    ref: ref\n  }, other), children));\n});\nexport default withStyles(styles, {\n  name: 'MuiTreeView'\n})(TreeView);","map":null,"metadata":{},"sourceType":"module"}