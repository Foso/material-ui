{"ast":null,"code":"import _extends from \"@babel/runtime-corejs2/helpers/esm/extends\";\nimport _Array$isArray from \"@babel/runtime-corejs2/core-js/array/is-array\";\nimport _objectWithoutProperties from \"@babel/runtime-corejs2/helpers/esm/objectWithoutProperties\";\nvar __jsx = React.createElement;\n\n/* eslint-disable jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions  */\nimport * as React from 'react';\nimport clsx from 'clsx';\nimport Typography from \"../../../material-ui/src/Typography\";\nimport Collapse from \"../../../material-ui/src/Collapse\";\nimport { fade, withStyles, useTheme } from \"../../../material-ui/src/styles\";\nimport { useForkRef } from \"../../../material-ui/src/utils\";\nimport TreeViewContext from \"../TreeView/TreeViewContext\";\nexport const styles = theme => ({\n  /* Styles applied to the root element. */\n  root: {\n    listStyle: 'none',\n    margin: 0,\n    padding: 0,\n    outline: 0,\n    WebkitTapHighlightColor: 'transparent',\n    '&:focus > $content $label': {\n      backgroundColor: theme.palette.action.hover\n    },\n    '&$selected > $content $label': {\n      backgroundColor: fade(theme.palette.primary.main, theme.palette.action.selectedOpacity)\n    },\n    '&$selected > $content $label:hover, &$selected:focus > $content $label': {\n      backgroundColor: fade(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),\n      // Reset on touch devices, it doesn't add specificity\n      '@media (hover: none)': {\n        backgroundColor: 'transparent'\n      }\n    }\n  },\n\n  /* Pseudo-class applied to the root element when expanded. */\n  expanded: {},\n\n  /* Pseudo-class applied to the root element when selected. */\n  selected: {},\n\n  /* Styles applied to the `role=\"group\"` element. */\n  group: {\n    margin: 0,\n    padding: 0,\n    marginLeft: 17\n  },\n\n  /* Styles applied to the tree node content. */\n  content: {\n    width: '100%',\n    display: 'flex',\n    alignItems: 'center',\n    cursor: 'pointer'\n  },\n\n  /* Styles applied to the tree node icon and collapse/expand icon. */\n  iconContainer: {\n    marginRight: 4,\n    width: 15,\n    display: 'flex',\n    flexShrink: 0,\n    justifyContent: 'center',\n    '& svg': {\n      fontSize: 18\n    }\n  },\n\n  /* Styles applied to the label element. */\n  label: {\n    width: '100%',\n    paddingLeft: 4,\n    position: 'relative',\n    '&:hover': {\n      backgroundColor: theme.palette.action.hover,\n      // Reset on touch devices, it doesn't add specificity\n      '@media (hover: none)': {\n        backgroundColor: 'transparent'\n      }\n    }\n  }\n});\n\nconst isPrintableCharacter = str => {\n  return str && str.length === 1 && str.match(/\\S/);\n};\n\nconst TreeItem = React.forwardRef(function TreeItem(props, ref) {\n  const {\n    children,\n    classes,\n    className,\n    collapseIcon,\n    endIcon,\n    expandIcon,\n    icon: iconProp,\n    label,\n    nodeId,\n    onClick,\n    onFocus,\n    onKeyDown,\n    onMouseDown,\n    TransitionComponent = Collapse,\n    TransitionProps\n  } = props,\n        other = _objectWithoutProperties(props, [\"children\", \"classes\", \"className\", \"collapseIcon\", \"endIcon\", \"expandIcon\", \"icon\", \"label\", \"nodeId\", \"onClick\", \"onFocus\", \"onKeyDown\", \"onMouseDown\", \"TransitionComponent\", \"TransitionProps\"]);\n\n  const {\n    icons: contextIcons,\n    focus,\n    focusFirstNode,\n    focusLastNode,\n    focusNextNode,\n    focusPreviousNode,\n    focusByFirstCharacter,\n    selectNode,\n    selectRange,\n    selectNextNode,\n    selectPreviousNode,\n    rangeSelectToFirst,\n    rangeSelectToLast,\n    selectAllNodes,\n    expandAllSiblings,\n    toggleExpansion,\n    isExpanded,\n    isFocused,\n    isSelected,\n    isTabbable,\n    multiSelect,\n    selectionDisabled,\n    getParent,\n    mapFirstChar,\n    addNodeToNodeMap,\n    removeNodeFromNodeMap\n  } = React.useContext(TreeViewContext);\n  const nodeRef = React.useRef(null);\n  const contentRef = React.useRef(null);\n  const handleRef = useForkRef(nodeRef, ref);\n  let icon = iconProp;\n  const expandable = Boolean(_Array$isArray(children) ? children.length : children);\n  const expanded = isExpanded ? isExpanded(nodeId) : false;\n  const focused = isFocused ? isFocused(nodeId) : false;\n  const tabbable = isTabbable ? isTabbable(nodeId) : false;\n  const selected = isSelected ? isSelected(nodeId) : false;\n  const icons = contextIcons || {};\n  const theme = useTheme();\n\n  if (!icon) {\n    if (expandable) {\n      if (!expanded) {\n        icon = expandIcon || icons.defaultExpandIcon;\n      } else {\n        icon = collapseIcon || icons.defaultCollapseIcon;\n      }\n\n      if (!icon) {\n        icon = icons.defaultParentIcon;\n      }\n    } else {\n      icon = endIcon || icons.defaultEndIcon;\n    }\n  }\n\n  const handleClick = event => {\n    if (!focused) {\n      focus(nodeId);\n    }\n\n    const multiple = multiSelect && (event.shiftKey || event.ctrlKey || event.metaKey); // If already expanded and trying to toggle selection don't close\n\n    if (expandable && !(multiple && isExpanded(nodeId))) {\n      toggleExpansion(event, nodeId);\n    }\n\n    if (!selectionDisabled) {\n      if (multiple) {\n        if (event.shiftKey) {\n          selectRange(event, {\n            end: nodeId\n          });\n        } else {\n          selectNode(event, nodeId, true);\n        }\n      } else {\n        selectNode(event, nodeId);\n      }\n    }\n\n    if (onClick) {\n      onClick(event);\n    }\n  };\n\n  const handleMouseDown = event => {\n    if (event.shiftKey || event.ctrlKey || event.metaKey) {\n      event.preventDefault();\n    }\n\n    if (onMouseDown) {\n      onMouseDown(event);\n    }\n  };\n\n  const printableCharacter = (event, key) => {\n    if (isPrintableCharacter(key)) {\n      focusByFirstCharacter(nodeId, key);\n      return true;\n    }\n\n    return false;\n  };\n\n  const handleNextArrow = event => {\n    if (expandable) {\n      if (expanded) {\n        focusNextNode(nodeId);\n      } else {\n        toggleExpansion(event);\n      }\n    }\n\n    return true;\n  };\n\n  const handlePreviousArrow = event => {\n    if (expanded) {\n      toggleExpansion(event, nodeId);\n      return true;\n    }\n\n    const parent = getParent(nodeId);\n\n    if (parent) {\n      focus(parent);\n      return true;\n    }\n\n    return false;\n  };\n\n  const handleKeyDown = event => {\n    let flag = false;\n    const key = event.key;\n\n    if (event.altKey || event.currentTarget !== event.target) {\n      return;\n    }\n\n    const ctrlPressed = event.ctrlKey || event.metaKey;\n\n    switch (key) {\n      case ' ':\n        if (nodeRef.current === event.currentTarget) {\n          if (multiSelect && event.shiftKey) {\n            selectRange(event, {\n              end: nodeId\n            });\n          } else if (multiSelect) {\n            selectNode(event, nodeId, true);\n          } else {\n            selectNode(event, nodeId);\n          }\n\n          flag = true;\n        }\n\n        event.stopPropagation();\n        break;\n\n      case 'Enter':\n        if (nodeRef.current === event.currentTarget && expandable) {\n          toggleExpansion(event);\n          flag = true;\n        }\n\n        event.stopPropagation();\n        break;\n\n      case 'ArrowDown':\n        if (multiSelect && event.shiftKey) {\n          selectNextNode(event, nodeId);\n        }\n\n        focusNextNode(nodeId);\n        flag = true;\n        break;\n\n      case 'ArrowUp':\n        if (multiSelect && event.shiftKey) {\n          selectPreviousNode(event, nodeId);\n        }\n\n        focusPreviousNode(nodeId);\n        flag = true;\n        break;\n\n      case 'ArrowRight':\n        if (theme.direction === 'rtl') {\n          flag = handlePreviousArrow(event);\n        } else {\n          flag = handleNextArrow(event);\n        }\n\n        break;\n\n      case 'ArrowLeft':\n        if (theme.direction === 'rtl') {\n          flag = handleNextArrow(event);\n        } else {\n          flag = handlePreviousArrow(event);\n        }\n\n        break;\n\n      case 'Home':\n        if (multiSelect && ctrlPressed && event.shiftKey) {\n          rangeSelectToFirst(event, nodeId);\n        }\n\n        focusFirstNode();\n        flag = true;\n        break;\n\n      case 'End':\n        if (multiSelect && ctrlPressed && event.shiftKey) {\n          rangeSelectToLast(event, nodeId);\n        }\n\n        focusLastNode();\n        flag = true;\n        break;\n\n      default:\n        if (key === '*') {\n          expandAllSiblings(event, nodeId);\n          flag = true;\n        } else if (multiSelect && ctrlPressed && key.toLowerCase() === 'a') {\n          selectAllNodes(event);\n          flag = true;\n        } else if (isPrintableCharacter(key)) {\n          flag = printableCharacter(event, key);\n        }\n\n    }\n\n    if (flag) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n\n    if (onKeyDown) {\n      onKeyDown(event);\n    }\n  };\n\n  const handleFocus = event => {\n    if (!focused && tabbable) {\n      focus(nodeId);\n    }\n\n    if (onFocus) {\n      onFocus(event);\n    }\n  };\n\n  React.useEffect(() => {\n    const childIds = React.Children.map(children, child => child.props.nodeId) || [];\n\n    if (addNodeToNodeMap) {\n      addNodeToNodeMap(nodeId, childIds);\n    }\n  }, [children, nodeId, addNodeToNodeMap]);\n  React.useEffect(() => {\n    if (removeNodeFromNodeMap) {\n      return () => {\n        removeNodeFromNodeMap(nodeId);\n      };\n    }\n\n    return undefined;\n  }, [nodeId, removeNodeFromNodeMap]);\n  React.useEffect(() => {\n    if (mapFirstChar && label) {\n      mapFirstChar(nodeId, contentRef.current.textContent.substring(0, 1).toLowerCase());\n    }\n  }, [mapFirstChar, nodeId, label]);\n  React.useEffect(() => {\n    if (focused) {\n      nodeRef.current.focus();\n    }\n  }, [focused]);\n  return __jsx(\"li\", _extends({\n    className: clsx(classes.root, className, expanded && classes.expanded, selected && classes.selected),\n    role: \"treeitem\",\n    onKeyDown: handleKeyDown,\n    onFocus: handleFocus,\n    \"aria-expanded\": expandable ? expanded : null,\n    \"aria-selected\": !selectionDisabled && isSelected ? isSelected(nodeId) : undefined,\n    ref: handleRef,\n    tabIndex: tabbable ? 0 : -1\n  }, other), __jsx(\"div\", {\n    className: classes.content,\n    onClick: handleClick,\n    onMouseDown: handleMouseDown,\n    ref: contentRef\n  }, __jsx(\"div\", {\n    className: classes.iconContainer\n  }, icon), __jsx(Typography, {\n    component: \"div\",\n    className: classes.label\n  }, label)), children && __jsx(TransitionComponent, _extends({\n    unmountOnExit: true,\n    className: classes.group,\n    in: expanded,\n    component: \"ul\",\n    role: \"group\"\n  }, TransitionProps), children));\n});\nexport default withStyles(styles, {\n  name: 'MuiTreeItem'\n})(TreeItem);","map":null,"metadata":{},"sourceType":"module"}