module.exports = "# API\n\n<p class=\"description\">The API reference of @material-ui/core/styles.</p>\n\n## `createGenerateClassName([options]) => class name generator`\n\n返回 [ 类名称生成器函数 ](https://cssinjs.org/jss-api/#generate-your-class-names) 的函数。\n\n#### 参数\n\n1. `options` (*Object* [optional]): \n  - `options.disableGlobal` (*Boolean* [optional]): 默认值为`false`。 Disable the generation of deterministic class names.\n  - `options.productionPrefix` (*String* [optional])：初始值为`'jss'`. 用于在生产中对类名称进行前缀的字符串。\n  - `options.seed` (*String* [optional])：初始值为 `''`. 用于唯一标识生成器的字符串。 It can be used to avoid class name collisions when using multiple generators in the same document.\n\n#### 返回结果\n\n`类名生成器`：应该将生成器提供给JSS。\n\n#### 例子\n\n```jsx\nimport React from 'react';\nimport { StylesProvider, createGenerateClassName } from '@material-ui/core/styles';\n\nconst generateClassName = createGenerateClassName({\n  productionPrefix: 'c',\n});\n\nexport default function App() {\n  return (\n    <StylesProvider generateClassName={generateClassName}>...</StylesProvider>\n  );\n}\n```\n\n## `createStyles(styles) => styles`\n\n这个函数在运行时并没有真正“做任何事”，它只是身份 函数。 Its only purpose is to defeat **TypeScript**'s type widening when providing style rules to `makeStyles`/`withStyles` which are a function of the `Theme`.\n\n#### 参数\n\n1. ` styles `(* Function | Object *): 生成样式或样式对象的函数。\n\n#### 返回结果\n\n`styles` ：生成样式或样式对象的函数。\n\n#### 例子\n\n```jsx\nimport { makeStyles, createStyles } from '@material-ui/core/styles';\n\nconst useStyles = makeStyles((theme: Theme) => createStyles({\n  root: {\n    backgroundColor: theme.color.red,\n  },\n}));\n\nexport default function MyComponent {\n  const classes = useStyles();\n  return <div className={classes.root} />;\n}\n```\n\n## `makeStyles(styles, [options]) => hook`\n\n链路的样式表中有一个功能组件的使用**钩**的模式。\n\n#### 参数\n\n1. ` styles `(* Function | Object *): 生成样式或样式对象的函数。 它将链接到组件。 如果需要访问主题, 请使用函数签名。 它作为第一个参数提供。\n2. `options` (*Object* [optional]): \n  - `options.defaultTheme`（*Object* [optional]）：如果未通过主题提供者提供主题，则使用默认主题。\n  - ` options.name ` (*String* [optional]): 样式表的名称。 用于调试。\n  - `options.flip` (*Boolean* [optional])：当设置为 `false` 时, 此工作表将选择退出 ` rtl ` 转换。 如果设置为 ` true `, 则会反转样式。 当设置为`null`，它跟随`theme.direction`。\n  - 其他键被转发到[jss.createStyleSheet([styles], [options])](https://cssinjs.org/jss-api/#create-style-sheet)。\n\n#### 返回结果\n\n`hook` ： 一个钩子。 该钩子可以用在功能组件中。 The documentation often calls this returned hook `useStyles`. 它接受一个参数：将用于在“内插”的属性 样式表。\n\n#### 例子\n\n```jsx\nimport React from 'react';\nimport { makeStyles } from '@material-ui/core/styles';\n\nconst useStyles = makeStyles({\n  root: {\n    backgroundColor: 'red',\n    color: props => props.color,\n  },\n});\n\nexport default function MyComponent(props) {\n  const classes = useStyles(props);\n  return <div className={classes.root} />;\n}\n```\n\n## `ServerStyleSheets`\n\nThis is a class helper to handle server-side rendering. [You can follow this guide for a practical approach](/guides/server-rendering/).\n\n```jsx\nimport ReactDOMServer from 'react-dom/server';\nimport { ServerStyleSheets } from '@material-ui/core/styles';\n\nconst sheets = new ServerStyleSheets();\nconst html = ReactDOMServer.renderToString(sheets.collect(<App />));\nconst cssString = sheets.toString();\n\nconst response = `\n<!DOCTYPE html>\n<html>\n  <head>\n    <style id=\"jss-server-side\">${cssString}</style>\n  </head>\n  <body>${html}</body>\n</html>\n`;\n```\n\n### `new ServerStyleSheets([options])`\n\nThe instantiation accepts an options object as a first argument.\n\n1. `options` (*Object* [optional]): The options are spread as props to the [`StylesProvider`](#stylesprovider) component.\n\n### `sheets.collect(node) => React element`\n\nThe method wraps your React node in a provider element. It collects the style sheets during the rendering so they can be later sent to the client.\n\n### `sheets.toString() => CSS string`\n\nThe method returns the collected styles.\n\n⚠️ You must call `.collect()` before using this method.\n\n### `sheets.getStyleElement() => CSS React element`\n\nThe method is an alternative to `.toString()` when you are rendering the whole page with React.\n\n⚠️ You must call `.collect()` before using this method.\n\n## `styled(Component)(styles, [options]) => Component`\n\n链路的样式表中有一个功能组件的使用**styled components**的模式。\n\n#### 参数\n\n1. `Component` ：将被包装的组件。\n2. ` styles `(* Function | Object *): 生成样式或样式对象的函数。 它将链接到组件。 如果需要访问主题, 请使用函数签名。 It's provided as property of the first argument.\n3. `options` (*Object* [optional]): \n  - `options.defaultTheme`（*Object* [optional]）：如果未通过主题提供者提供主题，则使用默认主题。\n  - ` options.withTheme ` (*Boolean* [optional]): 默认值为 `false`。 将 ` theme ` 对象作为属性提供给组件。\n  - ` options.name ` (*String* [optional]): 样式表的名称。 用于调试。 如果未提供该值, 它将尝试回退到组件的名称。\n  - `options.flip` (*Boolean* [optional])：当设置为 `false` 时, 此工作表将选择退出 ` rtl ` 转换。 如果设置为 ` true `, 则会反转样式。 当设置为`null`，它跟随`theme.direction`。\n  - 其他键被转发到[jss.createStyleSheet([styles], [options])](https://cssinjs.org/jss-api/#create-style-sheet)。\n\n#### 返回结果\n\n`Component` ：创建新组件。\n\n#### 例子\n\n```jsx\nimport React from 'react';\nimport { styled } from '@material-ui/core/styles';\n\nconst MyComponent = styled('div')({\n  backgroundColor: 'red',\n});\n\nconst MyThemeComponent = styled('div')(({\n  theme\n}) => ({\n  padding: theme.spacing(1),\n}));\n\nexport default function StyledComponents() {\n  return (\n    <MyThemeComponent>\n      <MyComponent />\n    </MyThemeComponent>\n  );\n}\n```\n\n## `StylesProvider`\n\n此组件允许您更改样式解决方案的行为。 It makes the options available down the React tree thanks to the context.\n\n它最好应在**组件树的根目录中使用** 。\n\n#### Props\n\n| 名称                | 类型     | 默认值   | 描述                                                                                                                                                                                                                                                                                                                                   |\n|:----------------- |:------ |:----- |:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| children&nbsp;*   | node   |       | Your component tree.                                                                                                                                                                                                                                                                                                                 |\n| disableGeneration | bool   | false | You can disable the generation of the styles with this option. It can be useful when traversing the React tree outside of the HTML rendering step on the server. Let's say you are using react-apollo to extract all the queries made by the interface server-side. You can significantly speed up the traversal with this property. |\n| generateClassName | func   |       | JSS's class name generator.                                                                                                                                                                                                                                                                                                          |\n| injectFirst       | bool   | false | By default, the styles are injected last in the `<head>` element of the page. As a result, they gain more specificity than any other style sheet. If you want to override Material-UI's styles, set this prop.                                                                                                                 |\n| jss               | object |       | JSS's instance.                                                                                                                                                                                                                                                                                                                      |\n\n\n#### 例子\n\n```jsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { StylesProvider } from '@material-ui/core/styles';\n\nfunction App() {\n  return (\n    <StylesProvider jss={jss}>...</StylesProvider>\n  );\n}\n\nReactDOM.render(<App />, document.querySelector('#app'));\n```\n\n## `ThemeProvider`\n\nThis component takes a `theme` property, and makes it available down the React tree thanks to the context. 它最好应在**组件树的根目录中使用** 。\n\n#### Props\n\n| 名称              | 类型                                       | 默认值 | 描述                                                                    |\n|:--------------- |:---------------------------------------- |:--- |:--------------------------------------------------------------------- |\n| children&nbsp;* | node                                     |     | Your component tree.                                                  |\n| theme&nbsp;*    | union:&nbsp;object&nbsp;&#124;&nbsp;func |     | A theme object. You can provide a function to extend the outer theme. |\n\n\n#### 例子\n\n```jsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { ThemeProvider } from '@material-ui/core/styles';\n\nconst theme = {};\n\nfunction App() {\n  return (\n    <ThemeProvider theme={theme}>...</ThemeProvider>\n  );\n}\n\nReactDOM.render(<App />, document.querySelector('#app'));\n```\n\n## `useTheme() => theme`\n\n该钩子返回`theme`对象因此可以在函数组件中使用。\n\n#### 返回结果\n\n`theme`: The theme object previously injected in the context.\n\n#### 例子\n\n```jsx\nimport React from 'react';\nimport { useTheme } from '@material-ui/core/styles';\n\nexport default function MyComponent() {\n  const theme = useTheme();\n\n  return <div>{`spacing ${theme.spacing}`}</div>;\n}\n```\n\n## `withStyles(styles, [options]) => higher-order component`\n\n链路的样式表有分量利用**higher-order component**的模式。 它不会修改传递给它的组件；相反，它返回一个具有`classes`属性的新组件。 这个`classes`对象包含DOM中注入的class名称。\n\n一些可能有趣的实现细节：\n\n- 它添加了一个 `classes` 属性，因此您可以从外部覆盖注入的类名。\n- It forwards refs to the inner component.\n- The `innerRef` prop is deprecated. Use `ref` instead.\n- It does **not** copy over statics. 例如，它可用于定义 ` getInitialProps()` 静态方法 (next.js)。\n\n#### 参数\n\n1. ` styles `(* Function | Object *): 生成样式或样式对象的函数。 它将链接到组件。 如果需要访问主题, 请使用函数签名。 它作为第一个参数提供。\n2. `options` (*Object* [optional]): \n  - `options.defaultTheme`（*Object* [optional]）：如果未通过主题提供者提供主题，则使用默认主题。\n  - ` options.withTheme ` (*Boolean* [optional]): 默认值为 `false`。 将 ` theme ` 对象作为属性提供给组件。\n  - ` options.name ` (*String* [optional]): 样式表的名称。 用于调试。 如果未提供该值, 它将尝试回退到组件的名称。\n  - `options.flip` (*Boolean* [optional])：当设置为 `false` 时, 此工作表将选择退出 ` rtl ` 转换。 如果设置为 ` true `, 则会反转样式。 当设置为`null`，它跟随`theme.direction`。\n  - 其他键被转发到[jss.createStyleSheet([styles], [options])](https://cssinjs.org/jss-api/#create-style-sheet)。\n\n#### 返回结果\n\n`higher-order component`：应用于包装组件。\n\n#### 例子\n\n```jsx\nimport React from 'react';\nimport { withStyles } from '@material-ui/core/styles';\n\nconst styles = {\n  root: {\n    backgroundColor: 'red',\n  },\n};\n\nfunction MyComponent(props) {\n  return <div className={props.classes.root} />;\n}\n\nexport default withStyles(styles)(MyComponent);\n```\n\n此外, 还可以像这样使用 [修饰器](https://babeljs.io/docs/en/babel-plugin-proposal-decorators):\n\n```jsx\nimport React from 'react';\nimport { withStyles } from '@material-ui/core/styles';\n\nconst styles = {\n  root: {\n    backgroundColor: 'red',\n  },\n};\n\n@withStyles(styles)\nclass MyComponent extends React.Component {\n  render () {\n    return <div className={this.props.classes.root} />;\n  }\n}\n\nexport default MyComponent\n```\n\n## `withTheme(Component) => Component`\n\n提供`theme` object作为输入组件的属性，因此可以在render方法中使用 。\n\n#### 参数\n\n1. `Component` ：将被包装的组件。\n\n#### 返回结果\n\n`Component` ：创建新组件。 Does forward refs to the inner component.\n\n#### 例子\n\n```jsx\nimport React from 'react';\nimport { withTheme } from '@material-ui/core/styles';\n\nfunction MyComponent(props) {\n  return <div>{props.theme.direction}</div>;\n}\n\nexport default withTheme(MyComponent);\n```"