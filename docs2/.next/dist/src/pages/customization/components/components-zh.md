module.exports = "# 自定义组件\n\n<p class=\"description\">您可以轻松地自定义一个 Material-UI 组件的外观。</p>\n\n有多种方法可以实现在不同的上下文环境中使用组件。 从最狭窄的用例到最广泛的用例，这些是：\n\n1. [一次性使用的特定变体](#1-specific-variation-for-a-one-time-situation)\n2. [一次性使用的动态变体](#2-dynamic-variation-for-a-one-time-situation)\n3. [在不同环境中使用组件的](#3-specific-variation-of-a-component) 特定变体\n4. [材料设计变体](#4-material-design-variations) 例如按钮组件\n5. [全局化主题变体](#5-global-theme-variation)\n\n## 1。 一次性使用的特定变体\n\n您可能需要为特定实现更改组件的样式，您可以使用以下解决方案：\n\n### 用类名覆盖样式\n\n覆盖组件样式的第一种方法是使用**类名** 。 每个组件都提供` className `，它是一个始终应用于根元素的属性。\n\n此示例使用[` withStyles() `](/styles/basics/#higher-order-component-api)高阶组件将自定义样式注入DOM，并通过它的` classes `属性将class名称传递给 `ClassNames` 组件。 您可以选择[任何其他的样式解决方案](/guides/interoperability/)或甚至简单的CSS创建的样式，但一定要 考虑[ CSS注入顺序](/styles/advanced/#css-injection-order) ，当通过Material-UI将CSS注入DOM对组件进行样式化， 这些CSS将具有最高的优先级，因为`<link>`被注入到` <head />` 的底部以确保组件始终能被正确地渲染。\n\n{{\"demo\": \"pages/customization/components/ClassNames.js\"}}\n\n### 用类覆盖样式\n\n当` className时`属性不够用，你需要访问更深层的元素，你可以利用`classes` 对象属性，来自定义该组件中所有由Material-UI注入的CSS。\n\nThe list of classes for each component is documented in the component API page, you should refer to the **CSS section** and **rule name column**. 例如，您可以查看[ Button CSS API ](/api/button/#css) 。 或者，您可以使用[浏览器中的 devtools](#using-the-dev-tools) 。\n\n这个例子也使用了 `withStyles()` （见上文），但在这里， `ClassesNesting` 使用 `Button` 的 `classes` 属性来接收一个对象，该对象将 **要覆盖的classes子项名** （样式规则）映射到 **对应的CSS属性名称** （值）。 组件的现有类将继续被注入，因此只需要提供你想要添加或覆盖的特定样式。\n\n请注意，除按钮样式外，按钮标签的大小写也已更改：\n\n{{\"demo\": \"pages/customization/components/ClassesNesting.js\"}}\n\n### Overriding styles with global class names\n\n[Follow this section](/styles/advanced/#with-material-ui-core).\n\n### 使用开发工具\n\n使用浏览器中的devtools可以为您节省大量时间。 在开发环境中：Material-UI的class名称[遵循一个简单的模式](/styles/advanced/#class-names)： ` Mui [组件名称] - [样式规则名称] -[UUID]` 。\n\n让我们回到上面的演示。 你是如何能覆盖按钮标签的？\n\n![dev-tools](/static/images/customization/dev-tools.png)\n\n使用开发工具，您知道需要定位 `按钮` 组件和 `标签` 样式规则：\n\n```jsx\n<Button classes={{ label: 'my-class-name' }} />\n```\n\n### Shorthand\n\n上面的代码示例可以通过使用**相同的CSS API**作为子组件被固定。 在此示例中， `withStyles()` 高阶分量正在注入由 [`Button` 组件](/api/button/#css)使用的 `classes` 属性。\n\n```jsx\nconst StyledButton = withStyles({\n  root: {\n    background: 'linear-gradient(45deg, #FE6B8B 30%, #FF8E53 90%)',\n    borderRadius: 3,\n    border: 0,\n    color: 'white',\n    height: 48,\n    padding: '0 30px',\n    boxShadow: '0 3px 5px 2px rgba(255, 105, 135, .3)',\n  },\n  label: {\n    textTransform: 'capitalize',\n  },\n})(Button);\n```\n\n{{\"demo\": \"pages/customization/components/ClassesShorthand.js\"}}\n\n### 伪类\n\n组件特殊状态，如* hover * ，* focus * ，* disabled *和* selected * ，具有更高的CSS特异性。 [特异性是一种重量](https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity)这适用于给定的CSS声明。\n\n为了覆盖组件的特殊状态，**需要提高特异性** 。 下面是一个示例，其中 *disabled* 状态，按钮组件使用 **伪类** （`disabled`）：\n\n```css\n.Button {\n  color: black;\n}\n.Button:disabled { /* Increase the specificity */\n  color: white;\n}\n```\n\n```jsx\n<Button disabled className=\"Button\">\n```\n\n有时，您不能使用**伪类**，因为该平台中不存在该状态。 我们以菜单项组件和 *selected* 状态为例。 除了访问嵌套元素之外，还有`classes` 属性可用于自定义Material-UI组件的特殊状态：\n\n```css\n.MenuItem {\n  color: black;\n}\n.MenuItem.selected { /* Increase the specificity */\n  color: blue;\n}\n```\n\n```jsx\n<MenuItem selected classes={{ root: 'MenuItem', selected: 'selected' }}>\n```\n\n#### 为什么我需要增加特异性以覆盖一个组件状态？\n\n通过设计，CSS规范使伪类增加了特异性。 为了保持一致性，Material-UI增加了其自定义伪类的特异性。 这有一个重要的优点，它允许您挑选您想要自定义的状态。\n\n#### 我可以使用不同API吗？这样会需要更少样板。\n\n您可以基于由Material-UI生成的[全局类名](/styles/advanced/#with-material-ui-core)，而不是为`classes`提供 prop API的值。 它实现了所有这些自定义伪类：\n\n| classes键     | 全局类名             |\n|:------------ |:---------------- |\n| checked      | Mui-checked      |\n| disabled     | Mui-disabled     |\n| error        | Mui-error        |\n| focused      | Mui-focused      |\n| focusVisible | Mui-focusVisible |\n| required     | Mui-required     |\n| expanded     | Mui-expanded     |\n| selected     | Mui-selected     |\n\n\n```css\n.MenuItem {\n  color: black;\n}\n.MenuItem.Mui-selected { /* Increase the specificity */\n  color: blue;\n}\n```\n\n```jsx\n<MenuItem selected className=\"MenuItem\">\n```\n\n### 在同一样式表中，使用 `$ruleName` 引用本地规则\n\n[ jss-nested ](https://github.com/cssinjs/jss-nested)插件 (默认情况下可用) 可以使增加特异性的过程更容易。\n\n```js\nconst styles = {\n  root: {\n    '&$disabled': {\n      color: 'white',\n    },\n  },\n  disabled: {},\n};\n```\n\n会编译为：\n\n```css\n.root-x.disable-x {\n  color: white;\n}\n```\n\n⚠️您需要将两个生成的类名称（`root` & `disabled`）应用于DOM以使其工作。\n\n```jsx\n<Button\n  disabled\n  classes={{\n    root: classes.root, // class name, e.g. `root-x`\n    disabled: classes.disabled, // class name, e.g. `disabled-x`\n  }}\n>\n```\n\n{{\"demo\": \"pages/customization/components/ClassesState.js\"}}\n\n### 覆盖内联样式\n\n覆盖组件样式的第二种方法是使用 **inline-style** 方法。 每个组件都提供`style`属性。 这些属性始终应用于根元素。\n\n您不必担心CSS特异性，因为内联样式优先于常规CSS。\n\n{{\"demo\": \"pages/customization/components/InlineStyle.js\"}}\n\n[我什么时候应该使用内联式vs类？](/getting-started/faq/#when-should-i-use-inline-style-vs-classes)\n\n## 2。 一次性使用的动态变体\n\n您在上一节中，已经学习了如何覆盖Material-UI组件的样式。 现在，让我们看看我们如何使这些覆盖动态化。 这有五种选择，每种都有它的优点和缺点。\n\n### 动态CSS\n\n{{\"demo\": \"pages/customization/components/DynamicCSS.js\"}}\n\n### 类名称分支\n\n{{\"demo\": \"pages/customization/components/DynamicClassName.js\"}}\n\n### CSS变量\n\n{{\"demo\": \"pages/customization/components/DynamicCSSVariables.js\"}}\n\n### 内联样式\n\n{{\"demo\": \"pages/customization/components/DynamicInlineStyle.js\"}}\n\n### Theme nesting\n\n{{\"demo\": \"pages/customization/components/DynamicThemeNesting.js\"}}\n\n## 3。 在不同环境中使用组件的特定变体\n\n您可能需要创建组件的变体并在不同的上下文中使用它，例如产品页面上的彩色按钮，但是您可能希望保持代码[* DRY *](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) 。\n\n最好的方法是遵循选项1，然后通过导出自定义组件来利用React的组合功能，以便在任何需要的地方使用。\n\n{{\"demo\": \"pages/customization/components/Component.js\", \"hideEditButton\": true}}\n\n## 4、 Material Design 变体\n\nMaterial Design规范记录了某些组件的不同变体，例如按钮的形状如何不同：[text](https://material.io/design/components/buttons.html#text-button) (以前称为“flat”)，[contained](https://material.io/design/components/buttons.html#contained-button) (以前称为“raised”)，[ FAB ](https://material.io/design/components/buttons-floating-action-button.html)或者更多。\n\nMaterial-UI尝试实现所有这些变体。 请参阅[支持的组件](/getting-started/supported-components/)文档，找出您想要的所有支持的Material Design组件的当前状态。\n\n## 5、 全局化主题变体\n\n为了提高组件之间的一致性，并整体化管理用户界面外观，Material-UI提供了一种应用全局更改的机制。\n\n本节的示例介绍了如何更改按钮的字体大小。\n\n### Theme variables\n\nYou can adjust the [theme configuration variables](/customization/theming/#theme-configuration-variables).\n\n```jsx\nconst theme = createMuiTheme({\n  typography: {\n    button: {\n      fontSize: '1rem',\n    },\n  },\n});\n```\n\n{{\"demo\": \"pages/customization/components/ThemeVariables.js\"}}\n\n### 全局CSS覆盖\n\n您还可以使用CSS自定义组件的所有实例。 Components expose [global class names](/styles/advanced/#with-material-ui-core) to enable this. 它与您自定义Bootstrap的方式非常相似。\n\n```jsx\nconst GlobalCss = withStyles({\n  // @global由jss-plugin-global处理。\n  '@global': {\n    //如果嵌套主题，则应该定位[class * =“MuiButton-root”]。\n    '.MuiButton-root': {\n      fontSize: '1rem',\n    },\n  },\n})(() => null);\n\n// …\n\n<GlobalCss />\n```\n\n{{\"demo\": \"pages/customization/components/GlobalCssOverride.js\", \"iframe\": true, \"height\": 70}}\n\n### 全局主题覆盖\n\n您可以利用`可被覆盖`的`主题`的键，这样可以改变由Material-UI注入的每个单独样式。 在[主题部分](/customization/globals/#css)可以了解有关它的更多信息。\n\n```jsx\nconst theme = createMuiTheme({\n  overrides: {\n    MuiButton: {\n      root: {\n        fontSize: '1rem',\n      },\n    },\n  },\n});\n```\n\n{{\"demo\": \"pages/customization/components/GlobalThemeOverride.js\"}}"